[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GEMS-MagTIP",
    "section": "",
    "text": "The documentation of GEMS-MagTIP: https://cgrg-lab.github.io/GEMS-MagTIP/\nHere is a quick guide:"
  },
  {
    "objectID": "index.html#introduction-to-gems-magtip",
    "href": "index.html#introduction-to-gems-magtip",
    "title": "GEMS-MagTIP",
    "section": "Introduction to GEMS-MagTIP",
    "text": "Introduction to GEMS-MagTIP\nGEMS-MagTIP is an integrated algorithm that calculates the Time of Increased Probability (TIP) for earthquakes based on geoelectric and geomagnetic field data. It represents the culmination of advancements from the earlier GEMSTIP (GeoElectric Monitoring System’s TIP) and MagTIP systems, combining their methodologies into a multivariate framework that supports diverse data sources.\n\n\n\nSchematic illustration of the TIP concept\n\n\n\nHistorical Development\nThe development began with GEMSTIP (Geoelectric Monitoring System’s Time of Increased Probability), which focused on geoelectric field anomalies. GEMSTIP utilized predictive modeling, binary classification, and statistical analysis to identify earthquake precursors in geoelectric data. This system demonstrated significant correlations between geoelectric anomalies and seismic events and was instrumental in establishing the feasibility of probabilistic earthquake forecasting.\nBuilding upon GEMSTIP, MagTIP expanded the algorithm to include geomagnetic field data. It greatly improves computational efficiency, support for both full-field and triaxial magnetic data, and introduces a rolling forecast system. MagTIP’s advancements made it possible to integrate data from both modern and legacy instruments, ensuring the preservation and utilization of valuable historical records.\n\n\n\nHistorical milestones of GEMS-MagTIP development\n\n\n\n\nGEMS-MagTIP: Unified and Multivariate\nThe current GEMS-MagTIP system integrates the capabilities of both GEMSTIP and MagTIP, enabling the simultaneous use of geoelectric and geomagnetic data. This multivariate system supports a wide range of geo-electromagnetic data types, including three-component and one-component signals, in the calculation of statistical indicators (e.g., skewness, kurtosis, Fisher Information, Shannon Entropy) for earthquake’s time of increased probability.\nGEMS-MagTIP system represents an advancement in earthquake precursor research. It provides a robust and adaptable tool to identify geo-electromagnetic anomalies correlated with large earthquake events, and allows joint-station probabilistic earthquake forecasting based on the concept of TIP.\n\n\n\nGeo-electric and magnetic stations in the Taiwan Geophysical Network for Seismology, TGNS.\n\n\n\n\n\n\n\n\n\n\n\nGEMS-MagTIP probability forecast (map)\n\n\n\n\n\n\n\nGEMS-MagTIP probability forecast (time-series)"
  },
  {
    "objectID": "doc_quickguide/index.html#setup-the-environment-and-add-dependencies",
    "href": "doc_quickguide/index.html#setup-the-environment-and-add-dependencies",
    "title": "A Quick Guide to GEMS-MagTIP Documentation",
    "section": "Setup the environment and add dependencies",
    "text": "Setup the environment and add dependencies"
  },
  {
    "objectID": "doc_quickguide/index.html#prepare-data",
    "href": "doc_quickguide/index.html#prepare-data",
    "title": "A Quick Guide to GEMS-MagTIP Documentation",
    "section": "Prepare data",
    "text": "Prepare data\n\n\nCatalog data"
  },
  {
    "objectID": "doc_quickguide/index.html#prepare-data-1",
    "href": "doc_quickguide/index.html#prepare-data-1",
    "title": "A Quick Guide to GEMS-MagTIP Documentation",
    "section": "Prepare data",
    "text": "Prepare data\n\n\nData of standard format in GEMS-MagTIP\n\n\n\n\nSee also conv_geomagdata and conv_gemsdata."
  },
  {
    "objectID": "doc_quickguide/index.html#setup-outputdependency-paths",
    "href": "doc_quickguide/index.html#setup-outputdependency-paths",
    "title": "A Quick Guide to GEMS-MagTIP Documentation",
    "section": "Setup output/dependency paths",
    "text": "Setup output/dependency paths\n\n\n\n\n\n\nSee also: Tips on directory select and assignment."
  },
  {
    "objectID": "doc_quickguide/index.html#an-example-of-the-overall-workflow",
    "href": "doc_quickguide/index.html#an-example-of-the-overall-workflow",
    "title": "A Quick Guide to GEMS-MagTIP Documentation",
    "section": "An example of the overall workflow",
    "text": "An example of the overall workflow\n\n⚠️ This is only a script for demonstration; please according to your purpose to assign parameters.\n\n%% Convert Raw data to standard type\n% Load original data and save them as matfiles of the standard format\n\nconv_gemsdata(dir_gems_raw, dir_data, dir_catalog,'FilterByDatetime',datetime(2020,1,1)); % Convert raw GE data of timestamps after 2020-1-1 to standard format. \n% Assign 'FilterByDatetime' to save time when standard geomagnetic data out of the specified date-time range already exist. \n% Discard 'FilterByDatetime' to convert everything in the raw-data directory.\nconv_geomagdata(dir_mag_raw, dir_data,'FilterByDatetime',datetime(2020,1,1)); % The same as above but for the conversion of GM data.\n\n%% Calculate Statistic Index\nstatind_parfor(dir_data,dir_stat, ... % Load data in dir_data, save index in dir_stat\n    'Preprocess',{'ULF_A','ULF_B','BP_40','BP_35'}, ... % with 4 kinds of filtering\n    'SavePreprocessedData',false, ... % without saving filtered timeseries\n    'StatName', {'S', 'K', 'FI', 'SE'},  ... % the variable name for 'StatFunction'.\n    'StatFunction', {@skewness, @kurtosis, @fisherinformation, @shannonentropy}, ...\n    'FilterByDatetime',[datetime(2011,1,1), datetime(2022,12,31)]); \n% Assign 'FilterByDatetime' to calculate statistical indices only between 2011-1-1 and 2022-12-31. \n% Noted that standard format GE/GM data have to be available in this range, otherwise you will get NaN if data is missing (or not converted) in `dir_data`.\n\n\n%% Data overview\n% An overview of data avaliability/deficiency according to the results in dir_stat \nplot_dataoverview(dir_stat, dir_catalog);\n\n%% Calculate Anomaly Indices\nanomalyind(dir_stat,dir_tsAIN);\n\n%% Training\nmolscore_parfor(dir_tsAIN,dir_catalog,dir_molchan,... \n    'TrainingPhase', {calyears(3),datetime(2022,4,1);... % Use up to 3-years data before 2022-4-1 for model training.\n                      calyears(5),datetime(2022,4,1);... % Use up to 5-years data before 2022-4-1 for model training.\n                      calyears(7),datetime(2022,4,1);... % Use up to 7-years data before 2022-4-1 for model training.\n                      calyears(9),datetime(2022,4,1)},...% Use up to 9-years data before 2022-4-1 for model training.\n    'modparam',{'Test', 5000}); % Remember to disable 'Test' in a real run.\n\n%% Forecast and test\nmolscore3_parfor(dir_tsAIN,dir_molchan,dir_catalog,dir_jointstation,...\n    'OverwriteFile',true, ...\n    'ForecastingPhase', repmat([datetime(2022,4,2), datetime(2022,9,27)], 4,1));\n    % Manually assign forecasting phases. Typically the size of 'ForecastingPhase' should align with the size of 'TrainingPhase'.\nSee also /GEMS-MagTIP-insider/demo/demo_script.m and\n\n\n\nLoad raw data and convert it into a standard format\nmain functions\n\n\n\nAvailable Preprocessing Functions\nTips on parallel computing"
  },
  {
    "objectID": "doc_quickguide/index.html#visualization",
    "href": "doc_quickguide/index.html#visualization",
    "title": "A Quick Guide to GEMS-MagTIP Documentation",
    "section": "Visualization",
    "text": "Visualization\n\n\nAlso see: Plotting functions"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "doc_library/index.html",
    "href": "doc_library/index.html",
    "title": "Library",
    "section": "",
    "text": "Warning\n\n\n\n\nPlease don’t assign undocumented name-value pair parameters to the functions. For example, 'CreateInfoOnly' and 'InParforLoop', which are preserved for parallel computing, and you will never need to set them manually unless you are a developer."
  },
  {
    "objectID": "doc_library/index.html#main-functions",
    "href": "doc_library/index.html#main-functions",
    "title": "Library",
    "section": "Main Functions",
    "text": "Main Functions\nThere are four major stages in the complete GEMS-MagTIP workflow, and each stage is wrapped by the main functions as below:\n\nstatind: The calculation of statistical indices.\nanomalyind: The calculation of anomaly indices number according to statistical indices.\nmolscore: Training phase based on anomaly indices, which involves the calculation of single-station TIP, matching TIP by target earthquakes and calculate Molchan scores accordingly.\nmolscore3: Forecasting phase based on the model parameters of the highest Molchan scores, involving the calculation of joint-station TIP and probability based on the results of 2 and 3.\n\nThe four stages is wrapped by four functions with keyword arguments that we can customize some hyper parameters which are associated with model optimization and probability forecast.\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\n\nstatind\nstatind(dir_data,dir_output) calculate daily statistics (a statistical quantity as an index of the day) of the daily timeseries in dir_data. The output variables are stored in dir_output.\nExample:\nstatind(dir_data,dir_output,'StatName','S','StatFunction',@skewness, 'Preprocess', {'ULF_A','ULF_B'});\nIn which, dir_data is the directory for the time series in the standard format; dir_output is the dir_stat mentioned before.\nKeyword Arguments:\n\n'StatName'\n\nThe abbreviations for the name of statistical indices. They can be arbitrarily defined but have to be the same number of elements as that of 'StatFunction'.\nDefault is {'S','K'} (for Skewness and Kurtosis).\n\n'StatFunction'\n\nThe function handle for calculating statistical index.\nIt has to be of the same number of elements as that of 'StatName'\nDefault is {@skewness,@kurtosis} for calling the skewness() and kurtosis() functions.\n\n'Preprocess'\n\nApply filter(s) to time series loaded from dir_data.\nDefault is {'no'}, which applies only minimal preprocessings.\nUse prpfunctions() to list all available preprocessing functions.\nIf multiple preprocessing functions are applied, for example {'no', 'ULF_A'}, then two sets of result according to no-filter data and ULF_A band passed data are going to be produced.\n\n'FilterByDatetime'\n\nIt should be a two element datetime array.\nIf applied, all files with date time tag not in the range will be ignored.\nDefault is [datetime(0001,1,1), datetime(2999,12,31)], resulting in no data selection by date time tag.\n\n'UpdateExisting'\n\nIf true, the array size in the existing statistic indices (files starts with “[StatisticIndex]”) will be extended, and the DateTime in Information file in the dir_output will all be updated to cover the datetime of the data in dir_data. (Hint: use 'FilterByDatetime' to avoid re-calculate all data in the dir_data)\nDefault is false; that a complete new session starts with the old Info renamed.\nCurrently this option is not supported by statind_parfor.\nNoted that 'SkipExist' will be set to false if 'UpdateExisting' is true to avoid unexpected behavior (there must be something wrong that you update the array sizes of the existing files to adapt latest DateTime, but also skip the calculation of statistical indices for those files).\nNoted that 'UpdateExisting' not only extend the full date time list to the latest, but also to the earliest available data time obtained according to the data list of dir_data. Thus, you may like to apply 'FilterByDatetime' to prevent the update according to earlier pasts.\n\n'SkipExist'\n\nSet it true to skip calculations if in the current loop a file in dir_stat of the\n\nsame 'stn' and 'prp' already exists.\n\nA typical scenario to use this option is when your last calculation is not completed yet.\nDefault is false.\n\n'LoadFilters', dir_filter\n\nLoad all filters in dir_filter once for performance. See loadfilters, generalfilterprocess.\n\n\n\n\nstatind_parfor\nstatind_parfor is the parallel computing version of statind, it takes the same input arguments and keyword options as statind.\nNoted that the option 'UpdateExisting', true is not supported in statind_parfor; besides this option, all documented statind keyword arguments are supported as well as the following additional Keyword Arguments:\n\n'NumCore': Assign specific how many CPU workers to be used in the paralell pool.\nDefault is 0, that the number of CPU cores to be used for paralell computing is automatically decided.\n'ReverseDatalist': Simply reverse the list of data. This might save time when you try to continue from previous unfinished calculation with the 'SkipExist' set true. The default is false.\n\n\n\nanomalyind\nanomalyind(dir_stat,dir_output) calculates anomaly index number (AIN) according to a list of \\(A_\\text{thr}\\); dir_out is where the output variables stored.\nExample:\nanomalyind(dir_stat,dir_tsAIN);\nKeyword Arguments:\n\n'AthrList':\n\nthe list of \\(A_\\text{thr}\\) (the multiplier of the median value of the statistical indices within the moving time window)\ndefault is [1:10]\n\n'MovingWindow'\n\nthe moving-window length for calculating the median value mentioned above\ndefault is 1000 (days)\n\n\nInput and output:\n\nanomalyind takes the statistic index output from statind by loading them from dir_stat.\nThe calculated anomaly index is saved in dir_tsAIN.\n\n\n\nmolscore\nmolscore(dir_tsAIN,dir_catalog,dir_molchan) is responsible for single station’s TIP & Molchan score calculation.\nExample:\ndir_catalog = 'Workspace/GEMS-MagTIP-insider/spreadsheet';\ndir_tsAIN = 'Workspace/var-output/tsAIN-J13-TZ2';\ndir_molchan = 'Workspace/var-output/MolchanScore-J13-TZ2';\nmolscore(dir_tsAIN,dir_catalog,dir_molchan);\nKeyword Arguments:\n\n‘TrainingPhase’\n\nAssigns a (set of) training phase(s). It should be of type 'calendarDuration', 'duration', an N by 2 array of 'datetime', or an N by 2 cell array, where N is the number of the training phases. If given an N by 2 array specifying N training phases, then N sets of results will be produced separately, with output format being '[MolScore]stn[%x]ID[%s]prp[%s]dt[%s-%s].mat'.\nFor example, a 4 by 2 datetime array reshape(datetime(2009:2016,2,1),[],2) specifies the start and end date of 4 training phases, with the first column being the datetime of the start and the second column being the end of each training phases.\nFor example, a 3 by 2 cell array\n{calyears(7),datetime(2012,11,11);...\n calyears(7),datetime(2011,11,11);...\n calyears(7),datetime(2010,11,11)};\nspecifies the end day of the training phases as 2010-Nov-11, 2011-Nov-11 and 2012-Nov-11, all having a length of 7-year-long training period (i.e. calyears(7)). If the duration is negative (e.g. -calyears(7)), the datetime of the second column become the first day of each training phase.\nDefault is calyears(7), which specifies the end day of training phase the day before the last day of statistical indices or anomaly index number, with a length of 7 year period. That is, in default it “trains” and gives the best models according to the most recent 7-year data.\n\n‘modparam’\n\nSpecify the model parameters for grid search. It should be a cell array; all elements in the cell array will be directly passed into modparam() as input arguments.\nFor example, {'Athr',[1:2:10],'Rc',[20, 30]}.\nDefault is {}.\n\n‘AdditionalCheck’\n\nApply some additional check and tests. This option is for developer.\nDefault is false.\n\n'SkipExist'\n\nSet it true to skip calculations if there is a file in dir_output having exactly the same name already (which means, having the same filter tag, station name and training phase).\nA typical scenario to use this option is when your last calculation was aborted manually or interrupted by an error event.\nDefault is false.\n\n\nInput and output:\n\nmolscore takes anomaly indices from dir_tsAIN and earthquake catalog and station information from dir_catalog.\nThe output ranked models are saved in dir_molchan.\nIn the \"[MolchanScore]Information.mat\", Info.DateTime is inherited from \"[tsAIN]Information.mat\" (whose DateTime is inherited from \"[StatisticIndex]Information.mat\")\n\n\n\nmolscore_parfor\nmolscore_parfor is the parallel computing version of molscore, it takes the same input arguments and supports all documented keyword arguments as molscore.\n\n\nmolscore3\nmolscore3 calculates the joint-station TIP, the Molchan score between EQK and TIP, the Hit rate, and the earthquake probability. The calculation is based on optimized model given by molscore.\nExample:\ndir_catalog = 'Workspace/GEMS-MagTIP-insider/spreadsheet';\ndir_tsAIN = 'Workspace/var-output/tsAIN-J13-TZ2';\ndir_molchan = 'Workspace/var-output/MolchanScore-J13-TZ2';\ndir_jointstation = 'Workspace/var-output/JointStation-J13-TZ2';\nmolscore3(dir_tsAIN,dir_molchan,dir_catalog,dir_jointstation)\nKeyword Arguments:\n\n‘ForecastingPhase’\n\nCatalog will be filtered according to this parameter.\nIt can be a N by 2 datetime array with its size identical to the training phases (trnphase), specifying the time ranges of N forecasting phases.\nIt can be ‘calendarDuration’ or ‘duration’, saying T. In this case, saying the last day of the training phase is trnphase(i, end), the forecasting phases are set to start from trnphase(i, end) + 1, and end at trnphase(i, end) + T.\n‘auto’. In this case, forecasting phases are set to be as long as possible. That is, until the last day where tsAIN is available.\nDefault is one calendar year: calyears(1).\nAlso see formatForecastingPhase().\nNoted that the actual ProbabilityTime in the output is extended according to the maximum of leading time (Tlead) and predicting time (TPred) model parameters, to maximize the extent that the model can predict. For details, please see refer to the source code of jointstation for how ProbTime is defined.\n\n‘OverwriteFile’\n\nWhether to overwrite existing output files or not.\nDefault is true.\n\n‘ModelSelect’\n\nsee bestmodel()\n\n‘ModelSelectOP’\n\nsee bestmodel()\n\n‘ChooseBest’\n\nDefine the number of maximum best models for each station to be applied.\nDefault is 10, which means we pick the models of top 10 fitting degrees each station for calculating predicted TIP(s).\n\n‘CombinationNumber’\n\nDefine the total number of random combinations among the best models of each station for joint-station TIP calculation.\nDefault is 500, which means for every station a random permutation of ranking numbers (based on the fitting degree) of the best models is performed with each sequence of ranking number having 500 elements, and the ith joint-station model parameter combination is thus from the best models of each station indexed by the ith element of each permutation.\n\n‘WithExtra’\n\nIf ‘WithExtra’ is true, the returned InfoTable will include a variable for Other data.\nPlease refer the output arguments of jointstation.\nDefault is false.\n\n\nInput and output:\n\nmolscore3 takes anomaly indices from dir_tsAIN, earthquake catalog and station information from dir_catalog, and ranked model form dir_molchan.\nThe output probability is saved in dir_jointstation.\n\n\n\nmolscore3_parfor\nmolscore3_parfor is the parallel computing version of molscore3, it takes the same input arguments and supports all documented keyword arguments as molscore3."
  },
  {
    "objectID": "doc_library/index.html#load-raw-data-and-convert-it-into-a-standard-format",
    "href": "doc_library/index.html#load-raw-data-and-convert-it-into-a-standard-format",
    "title": "Library",
    "section": "Load raw data and convert it into a standard format",
    "text": "Load raw data and convert it into a standard format\nData of standard format denotes the formatted matfile that should contain only 1 field where the field name can be arbitrarily chosen. Saying the field to be M, M has to be a matrix where the column indices to time and data are assigned by function fmt.colindex2data (see fmt) depending on the type of the data.\n\n\n\n\n\n\nWarning\n\n\n\nNoted that fmt.colindex2data returns a set of indices for indexing into the data of standard format, whereas columnind (see docstring below) returns a set of indices for indexing into the raw data.\n\n\nThe naming of standard format data is critical. Please refer standarddataname in the following docstring for the naming rule.\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\n\nconv_gemsdata\nconv_gemsdata(dir_gems_raw, dir_data, dir_catalog) read original GEMS’s data (e.g., 2012_02_07_16_45_00.dat) in dir_gems_raw, merge and convert them to the standard format for GEMS-MagTIP.\nThe GEMS’s raw data is recorded at local time (UTC+8), and conv_gemsdata converts the time to UTC time.\nAlso see \"read_gemsdata.m\". Example:\ndir_gems_raw = 'rawdata/GEMSdat';\n% where the individual data locates in for example:\n% 'rawdata/GEMSdat/em10/REC/Y2012/M02/D07/2012_02_07_16_45_00.dat'\ndir_data = 'dataStandard/GE';\ndir_catalog = 'spreadsheet'; % for obtaining the station information (\"station_location.mat\");\nconv_gemsdata(dir_gems_raw, dir_data, dir_catalog);\nKeyword Argument:\n\n‘FilterByDatetime’: See conv_geomagdata.\n\n\n\nconv_geomagdata\nThe original geomagnetic data (which are those in “.csv” format being something like “2008010300.KM” or “20190307.LY”) should be converted to a standard format before any calculation. conv_geomagdata(dir_mag_raw, dir_data) read original data in dir_mag_raw and save them in the standard format at the directory dir_data.\nKeyword Argument:\n\n‘ContinueFromLast’: Default is false. If true, it compares the names of all old files in the dir_mag_raw and the new files in dir_data before conversion to avoid files that are already being converted to be converted again. This additional procedure may take several hours depending on the size of database; a more efficient way for avoiding repeated processing is to manually specify ‘FilterByDatetime’. See below.\n‘FilterByDatetime’: Only convert the files in the assigned time range(s). It supports:\n\nA datetime. For example, when 'FilterByDatetime', datetime(2010,10,10), only files with time tag being or after 2010-Oct-10 will be converted.\nN by 2 datetime array, for example,\n'FilterByDatetime', [datetime(2009,12,10), datetime(2010,10,10);...\n                     datetime(2013,12,10), datetime(2017,10,10)];\n, only the files in the two time ranges [2009-Dec-10, 2010-Oct-10] and [2013-Dec-10, 2017-Oct-10] will be converted; otherwise, ignored.\n\n‘Test’: It take only the assigned ratio (0-1) of data (files) in the directory dir_mag_raw. The files are randomly chosen. This option should only be applied when you want to test your code for reducing the overall computing time. Default is 0 (when the assigned value for ‘Test’ is \\(\\leq 0\\) or \\(\\geq 1\\), there is no reduction in the data list).\n\nNOTICE:\n\nFiles in the original format must be uniquely named as ‘20200101.HC’ or ‘2020010109.HC’ for example.\nIf not uniquely named, such as ‘../HC/20200101.txt’, ‘../CS/20200101.txt’, the second one will be regarded as a duplicated file and be moved out to an alternative folder (dir_alt)\nevery file should have its extension as the code of the corresponding station, e.g. ‘20200101.HC’ is correct; ‘20200101.txt’ is not valid and an error will occur.\n\n\n\nreadgems\nA general function for reading original gems data. It dispatch the task to the specified function according to file extension.\n\n\nread_gemsdat\nread yyyy_mm_dd_HH_MM_SS.dat from GEMS developed by AnaSystem The following is GEMS.dat format: Header is the first 100 bytes. All parameters in header is in a unit of 2 bytes Hence, the header has 50 fields.\n\n0-11 bytes is for date\n0-1: year\n2-3: month\n4-5: day\n6-7: hour\n8-9: minute\n10-11: second\n12-13: sampling rate\n14-15: Channel Options (15 has 4 CHs,255 has 4 CHs,7 has 3 CHs,3 has 2 CHs)\n16-99 bytes are padded by zero, for future use.\n\nFrom the 100th byte on, every 4 byte is used to restore data. The order is TimeStamp, Ch1, Ch2, Ch3, Ch4. If one channel is not used, skip it. e.g., only use chn1 and chn3, then recording order is TimeStamp, Ch1, Ch3, TimeStamp, Ch1, Ch3, and so on. In every cycle, TimeStamp is a 4-byte integer, time drift from the header time, unit is minisecond. channel’s data is 4-byte single-precision float. Note that the byte order of all data is “little endian.” The value of voltage is between -10 V and 10 V.\nfunction [data, header] = read_gemsdat(absolute_FileName) input: absolute_FileName: string, absolute full file name output: data = [time,chn1,chn2,chn3,chn4], N x 5 header = [yyyy;mm;dd;HH;MM;SS.SS;fs;chnOPT;…] built-in func: fopen, fclose, fread, fseek self-defined func:\nusage:\n[data, header] = read_gemsdat('g:\\GEMSdat\\em10\\REC\\Y2012\\M02\\D07\\2012_02_07_16_45_00.dat');\nOrigin\n\nreadanasystem.m\nAuthor: Han-Lun Hsu\n\nFirst modification\n\nMatlab version: 2018b\nAuthor: Hong-Jia Chen (redhouse6341@gmail.com)\nDate: 2018/07/01\n\nSecond modification\n\nMatlab version: 2021b\nAuthor: Hong-Jia Chen (redhouse6341@gmail.com)\nDate: 2021/10/11\n\n\nThe docstring is revised by Tsung-Hsi Wu in 2024.\n\n\n\ngeoelectric_projection\nOne field data of any direction can be determined by data of another two directions E(phi)=[-E1*sin(phi-theta2)+E2*sin(phi-theta1)]/sin(theta2-theta1) In this framework, make sure Common Electrode is negative for all channels That is, A is CH01+, B is CH02+, C is CH01- and CH02- function [E] = geoelectric_projection(phi, E1, theta1, E2, theta2) input: phi, theta1, theta2 = ‘degree’ from the north, positive for clockwise E1, E2 = field data of any two direction output: E = field data of the specific direction phi phi = 0 means north phi = 90 means east built-in func: sind numel user-defined func:\nusage:\n[E_EW] = geoelectric_projection(90, E_chn1, 15, E_chn2, 120); \n[E_NS] = geoelectric_projection(0, E_chn1, 15, E_chn2, 120); \n% where  East is positive;  North is positive\nReference\n\nTakahashi et al. (2005): ULF Electromagnetic Environment at Southern Boso Peninsula : Signal Discrimination of the Geoelectromagnetic Data\n\nOrigin\n\nMatlab version: 2018b\nAuthor: Hong-Jia Chen (redhouse6341@gmail.com)\nDate: 2020/09/02\n\n\nThe docstring is revised by Tsung-Hsi Wu in 2024.\n\n\n\ncolumnind\nReturn column indices for time, data and others according to the type field on the file name of standard format GE/GM data.\n\n\nstandarddataname\n[fname] = standarddataname(stnm, dtstr, type_j) returns the file name of the standard data format. For example, standarddataname('HUAL', '20120202', 'GEMS0') returns stn[HUAL]dt[20120202]type[GEMS0].mat.\n\n\nwrite_data\nGiven the reference tag strcheckwith (that automatically updated inside this function) and the reference tag strj (defined outside the function), write_data creates a new file fname if they are different, and write M into the same matObj if they are the same.\nExample In the following example, New matfile matObj is created in the first loop with matObj.M = M. In the subsequent loops, new data M will be appended to the same matObj.M until datestr is updated.\ndtstr0 = '00000000';\nmatObj = 0;\n    for j = 1:height(table_i)\n        dtstr_j = table_i{j, 'datestr'}; \n        ...\n        [matObj, dtstr0] = write_data(M, matObj, dtstr0, dtstr_j, dir_i, fname, dir_alt);\n    end"
  },
  {
    "objectID": "doc_library/index.html#available-preprocessing-functions",
    "href": "doc_library/index.html#available-preprocessing-functions",
    "title": "Library",
    "section": "Available Preprocessing Functions",
    "text": "Available Preprocessing Functions\nIn GEMS-MagTIP, signal processing is conducted via preprocessing functions, Preprocessing functions are special functions that are located in src/preprocess. The no function that simply import the data from a given file path is necessary. You can use prplist = prpfunctions() to list all preprocessing functions. Filtering functions (such as ULF_A,ULF_B in prplist) share the same core function generalfilterprocess that takes the output of loadfilters as their inputs.\n\nWhat do preprocessing functions do?\n\nimport data (namely, M)\ndo some pre-process (e.g., band-pass filtering)\noutput the processed data as a matrix the same columns as M\ncolumnind is applied in preprocessing functions to acquire the indices to time columns, data columns, and etc..\n\n\n\nYou can define your own preprocessing functions to work with statind, as the following points should be satisfied:\n\nThe first input argument should be the path fpath to the file of standard format.\nImport data from fpath.\nMake sure the column indices is compatible with columnind.\nPut the .m file for this customized function under the directory src/preprocess (put in the same place as no.m).\n\n\n\nHow to use preprocess functions\n\nVia the interface of statind: statind(..., 'Preprocess', 'ULF_A') (ULF_A can be substitute with any function name that prpfunctions() lists.\nSee Examples below:\n\n\n\nExamples\nThere are four built-in preprocessing functions, BP_35, BP_40, ULF_A, ULF_B; these filters can be applied in the statind stage via the 'Preprocess' keyword argument.\nHere is an example of the direct use (not via 'Preprocess' interface in the statind stage) of BP_35:\nfpath = 'D:\\GeoMag (main)\\GeoMag_GO\\KUOL\\stn[KUOL]dt[20150714]type[GEMS].mat';\nM_out = BP_35(fpath);\nIn this example, data is imported from fpath as variable, then call generalfilterprocess which by default use bandpass that creates a band-pass filter every time a data is imported, and output the filtered data as M_out having exactly the same column dimension as M (but with rows might be reduced).\nHere is another example, which apply existing filters (e.g., 'Filter[BP_35]samp[1]stp[093].mat') in dir_filter if possible:\nfpath = 'D:\\GeoMag (main)\\GeoMag_GO\\KUOL\\stn[KUOL]dt[20150714]type[GEMS].mat';\nfiltpaths = datalist('Filter*.mat', dir_filter);\nFOBJ = loadfilters(filtpaths); % load all filters as a struct FOBJ\nM_out = BP_35(fpath, FOBJ);\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\n\nBP_35\nThe preprocessing function that filter the loaded timeseries with 'BP_35' band-pass filter. It applies down sampling to 1 Hz before band-pass filtering ('Downsampling1Hz', true), and applies edge truncations right before output ('EdgeTruncate', 3162); please refer generalfilterprocess for more details. The lower and upper bounds of frequency are [10^(-3.5) 10^(-1.75)] (in unit Hz); please refer fmt.filterRange.\n\n\nBP_40\nThe preprocessing function that filter the loaded timeseries with 'BP_40' band-pass filter. It applies down sampling to 1 Hz before band-pass filtering ('Downsampling1Hz', true), and applies edge truncations right before output ('EdgeTruncate', 10000); please refer generalfilterprocess for more details. The lower and upper bounds of frequency are [10^(-4) 10^(-1.75)] (in unit Hz); please refer fmt.filterRange.\n \n\n\nULF_A\nThe preprocessing function that filter the loaded timeseries with the 'ULF_A' band-pass filter. It applies down sampling to 1 Hz before band-pass filtering ('Downsampling1Hz', true), and applies edge truncations right before output ('EdgeTruncate', 1000); please refer generalfilterprocess for more details. The lower and upper bounds of frequency are [0.001 0.003] (in unit Hz); please refer fmt.filterRange.\n\n\nULF_B\nThe preprocessing function that filter the loaded timeseries with the 'ULF_B' band-pass filter. It applies down sampling to 1 Hz before band-pass filtering ('Downsampling1Hz', true), and applies edge truncations right before output ('EdgeTruncate', 1000); please refer generalfilterprocess for more details. The lower and upper bounds of frequency are [0.001 0.01] (in unit Hz); please refer fmt.filterRange.\n\n\nno\nM_prp = no(fpath) does no preprocessing, loads and returns the data of fpath in the form of matrix.\nOther functions might also depends on no. For example, prpfunctions is dependent on no to get the directory of all functions for preprocessing.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\ngeneralfilterprocess is the core shared among 'ULF_X' and BP_X family; please refer Filtering Functions."
  },
  {
    "objectID": "doc_library/index.html#filtering-functions",
    "href": "doc_library/index.html#filtering-functions",
    "title": "Library",
    "section": "Filtering Functions",
    "text": "Filtering Functions\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\n\nautobandpassfilter\nGiven a file of standard format, create and save bandpass filter accordingly. See also fmt; generalfilterprocess.\n\n\nbutterfilt\nButterworth filter.\n\n\nfilterthedata\nM_dataf = filterthedata(M_input,prp_tag,...\n    'SamplingFrequency',fs,...\n    'RemoveOutliers',true);%\nwhere M_input is an n by m array where n is the number of data points, m is the number variable. That is, each row of M_input is a data point; each column is a variable.\n\n\ngeneralfilterprocess\nGiven prp_tag, generalfilterprocess(prp_tag, fpath, 'AvailableFilter', FOBJ) load data from fpath, filter only the data column and return the data as M_prp. The frequency range is inquiried through fmt.filterRange or FOBJ.(prp_tag).(fs_tag).\nIf FOBJ is provided, generalfilterprocess attempts to do filtering with filters in FOBJ; if there is no adequete filter in FOBJ, it applys filterthedata that generates filter for file fpath with warning message.\nOption:\n\n'EdgeTruncate', 1000: Truncate the head/tail by 1000 data points right before output.\n'AbnormalLowValue', 1e-6: Replace data of absolute values less than 1e-6 to NaN.\n\ngeneralfilterprocess involves the following processin; see the docsting therein:\n\nloadfilters for information about FOBJ, fs_tag and prp_tag.\nfmt for fmt.filterRange\nfilterthedata for automatically create a filter and do filtering\nfillNaN for interpolation (which is required before any filtering)\nautobandpassfilter for quickly making and saving filters.\n\n\n\nloadfilters\nF = loadfilters(filtpaths) load filters as a nested structure, that opts = F.(prp_tag).(fs_tag) is compatible to signal.internal.filteringfcns.filterData in bandpass. In which, prp_tag should be in the list of prpfunctions() and fs_tag is the sampling frequency prefixed by “fs” (e.g., ‘fs15’ for 15Hz).\nThe simplest way to create and save a filter is apply bandpass to data with a certain set of parameters, set debug point inside bandpass, and save opts in the debug scope. For canoical approaches, see Filter Design in Matlab.\nThe filters should named as ‘Filter[ULF_A]samp[15]….mat’ for example.\nThe input filtpaths should be a struct having name for file names and fullpath for file paths.\nSee also:\n\nprpfunctions(): list all preprocessing functions that might support F.\nsignal.internal.filteringfcns.filterData (Signal processing package of matlab)\nstatind(__)\n\n\n\ntry_generalfilterprocess\nA try-catch wrapper to avoid aborting execution due to error raised in generalfilterprocess."
  },
  {
    "objectID": "doc_library/index.html#internal-api-for-tip-calculation",
    "href": "doc_library/index.html#internal-api-for-tip-calculation",
    "title": "Library",
    "section": "Internal API for TIP Calculation",
    "text": "Internal API for TIP Calculation\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\n\nTIPArea\nGiven the Longitude Lon, Latitude Lat and the radius Rc, [isinS,insideRatio] = TIPArea(Lon,Lat,Rc,xLon,yLat) returns a logical vector indicating whether each grid point specified by xLon and yLat is inside Rc centered at (Lon, Lat).\nTIPArea used isInpolygon of okatsn/toolbox which simply splits circles by NaN before applying matlab’s inpolygon. In the official documentation of inpolygon in the section “Points Inside Multiply Connected Polygon”, if the polygon in the inner loop are defined in a counterclockwise direction while the outer one in a clockwise direction, inpolygon identifies the points inside the outer polygon but not inside the inner polygon. What the official documentation didn’t explicitly say is, if two (or more) polygons are all defined in the same direction, which is our case that all circles are defined in the counterclockwise direction, inpolygon identifies points in either polygon, which the expected behavior in our application. That is, when the TIP area of one station overlapped with the TIP area of another one station, isinS is true if a grid point is inside of either and (xLon(isinS), yLat(isinS)) are essentially the union of the TIP area of all stations.\nUnit:\n\nxLon (yLat): degree of longitude (latitude).\nRc: kilometer. Noted that Rc is convert to the unit of degree and be the mean of those based on the latitude and longitude of the center respectively. (Hint: when converting km to deg, it depends on latitude and the longitude. For example, at lower latitude, the distance of 1 deg interval in longitude is much larger than that of 1 deg interval at high latitude.)\n\nInput:\n\nxLon (yLat): N by 1 array for longitude (latitude)\nRc: M by 1 array of raddi\nLon, Lat: M by 1 array of the coordinate of centers each.\n\nOutput:\n\nisinS: a N by 1 array, where xLon(isinS),yLat(isinS) specify all the points (clearly non-repeated) that are within the ranges of radii Rc inside the centers specified by Lon, Lat.\n\n\n\nTIPspatialtemporal\nGiven the dates to calculate TIP area dates_TIPtrue, the range (Rc) around the center point (LatLon) in LatLonRc_TIPtrue, and the grid points of the entire map (xLon, yLat), [dt_TIP_true_uniq,TIP_true_area,isinTS] = TIPspatialtemporal(dates_TIPtrue,LatLonRc_TIPtrue, xLon, yLat) returns the unique and sorted vector of dates (dt_TIP_true_uniq) and the vector of spatial TIP area TIP_true_area for each date in dt_TIP_true_uniq.\nThe value of TIP_true_area is the ratio of spatial TIP area to total area. When in the context of calculating the total amount of alarmed area, sum(TIP_true_area) is the alarmed area ratio to the entire 2D space specified by xLon and yLat (i.e., which are all grid points in the region of [TwLat0, TwLat1],[TwLon0, TwLon1]). See TIPArea for more information.\nisinTS is a S by T logical array specifying spatial-temporal points that are within the ranges of radii Rc inside the centers specified by Lon, Lat, where [Rc, Lon, Lat] = LatLonRc_TIPtrue is a M by 3 array where \\(M \\geq T\\) must be satisfied.\nNoted that dt_TIP_true_uniq are successive (e.g., 1, 2, 4) dates but not necessarily consecutive (e.g., 1, 2, 3).\n\n\nbestmodel\n[BestModels,BestModelNames,idPermute,molList] = bestmodel(molList,BestN,totalM,StationLocation) filters the best N models out based on fitting degree and perform random permutation of total M combination of them. That is, bestmodel() save the best N (at most) models for each station in BestModels, and gives an array of M elements that are randomly picked from the set of the ranking numbers of the best N (at most) models.\nInput arguments:\n\nmolList: The list of paths to the files of ranked models, which are produced by molscore. Get the molList using datalist(...).\nBestN: The number the models of highest molchan score.\ntotalM: The amount of randomly permuted combinations of the best N models. That is, M is the number of joint-station models. Noted that the first model combination is forced to be the combination of the best model of each station.\nStationLocation: A J by 3 table with the column names being ‘format’, ‘Lon’, ‘Lat’ and row names (i.e. StationLocation.Properties.RowNames) the station codes (e.g. ‘TW’, ‘CS’,…) of the total J stations.\n\nOutput arguments:\n\nBestModels: A J-by-1 cell array containing the best models of total J stations. In each cell there is a table model parameters.\nBestModelNames: An J-by-1 cell array containing station names corresponding to BestModels (also J-by-1 cell array).\nidPermute: The randomly permuted indices for the best models. It is a J by 1 cell array, where each cell contains a M by 1 double array being the indices for the Jth BestModels. Noted that the first element in the M by 1 double array is always 1, which force the first model combination in jointstation() to be the combination of the best model of each station (SEE molscore3()).\nmolList: The list of paths to the files of ranked models, where the files having all molchan scores to be NaN (hence model parameters cannot be ranked) are excluded.\n\nKeyword Arguments:\n\n‘NearbyThreshold’: For some reasons (e.g. no target earthquakes at all in the training phase) models cannot be ranked (optimized) for a station (saying ‘MS’) because all molchan scores are NaN. In this situation, bestmodel will try to find if there is a near-by station within 15 km (in default). If there is, for example, a station ‘PT’ nearby within 15km of ‘MS’, then the ranked model ‘PT’ will be taken instead. That is, in the following process in molscore3, the best models of ‘PT’ and the AIN based on the geomagnetic data of ‘MS’ are applied for calculating the probabilities around the station of ‘MS’.\n‘ModelSelect’: You may filter the table of Molchan scores by using this option. For example, with 'ModelSelect', {'Tpred', 5}, all rows whose Tpred is not 5 will be discard.\n‘ModelSelectOP’\n\nThe operator function for model selecting if 'ModelSelect' have multiple pairs of input argument.\nFor example, with 'ModelSelect', {'Tpred', 5, 'Tlead', 5}, 'ModelSelectOP', @or, all rows with Tpred=5 or Tlead=5 was kept; others, discarded.\nDefault is @or.\n\n\n\n\nconvAIN\nCalculate the total amount of anomaly indices of each day. That is, saying we have two statistical indices S and K, and the total amount of anomaly indices is less or equal than 2. It is the ‘update_tsAIN’ of the previous version.\nExample:\n[sum_tsAIN, sum_validateIndex] = convAIN(tsAIN.Athr, tsAIN.validateIndex)\nFor each Athr we have one anomaly index (true or false) and validation index (true or false) per day per variable, and the output is the number of “trues” per day. Usually Athr = 1:10, so the output will be a 10 by 1 cell in each there is a N by 1 double; N is the length of the DateTime series.\nInput arguments:\n\ntsAIN.Athr or tsAIN.validateIndex: A 1-by-10 structure array. See anomalyind for more information.\n\nOutput arguments:\n\nsum_tsAIN or sum_validateIndex: A 10-by-1 cell array corresponding to \\(A_{thr} = 1:10\\). In each cell, there is a N-by-1 double array being the sum of anomaly indices or the sum of valid indices of N days.\n\n\n\ndt_TIP_true\n[dt_TIPtrue,TIPtime,TIP] = dt_TIP_true(DateTimeSAT,vlSAT, Tthr,Tlead,Tpred) return the datetime where TIP is true.\nInput arguments:\n\nDateTimeSAT: M-by-1 datetime array for sum of anomaly days\nvlSAT: M-by-1 double array for the values of sum of anomaly days (the anomaly days is summed in the moving window of Tobs)\nTthr: the threshold related to the number of anomaly days in Tobs\nTlead: the leading window right before the prediction window\nTpred: the window of prediction (where TIP is true or false according to the number of anmalies in the corresponding Tobs window)\n\nOutput arguments:\n\ndt_TIPtrue: the datetime where TIP is true\nTIPtime: an N-by-1 datetime array paired with the TIP array\nTIP: an N-by-1 logical array of Time of Increased Probability\n\nThe variable dt_TIPtrue may exceeds the last day of DateTimeSAT, while TIPtime is truncated to not exceed DateTimeSAT(end) in molscore, because in training phase datetime out of DateTimeSAT is assumed to be out of the time range of available earthquake catalog.\nA schematic illustration of the input/output variables:\nsum_validateIndex_all_a_dti (2nd input argument in sumanomalyind)\n               1100111011000001010010000000001010000000 (for example) \nDateTime_dti   tttttttttttttttttttttttttttttttttttttttt\nTobs length    |-----|  (Tobs=7, for example) \nTlead length          |-------| (Tlead=9, for example) \nvlSAT                5445543222122233222221112122344332 (for example) \nDateTimeSAT index    123456789.........................         \nDateTimeSAT    |Tobs |--------------------------------|         \nTIPtime/TIP    |Tobs || Tlead ||--------------------------------------|\n                               ↑                |Tobs || Tlead ||Tpred| \n                   Tpred start ↑        last AIN data ↑     Tpred end ↑    \n\n\ndt_TIP_valid\ndt_TIP_valid gives loosely valid TIP time and strictly invalid TIP time. There are two possibilities for a TIP false: one is that the anomaly index number (AIN) is below the threshold, and the other is that AIN is NaN since anything in comparison with a NaN results in a false. The later we called it an ‘invalid’ TIP time/day.\nExample:\n[TIPtime1,TIP_valid,dates_TIPvalid_st,dates_TIPinvalid_st] = ...\ndt_TIP_valid(DateTimeSAT,sum_validateIndex_all_a_dti,Tobs,Tlead,Tpred)\nThis gives the datetime where there is at least one data in the Tobs and hence TIP false is a valid false.\nInput arguments:\n\nDateTimeSAT: see sumanomalyind()\nsum_validateIndex_all_a_dti: the sum_validateIndex in convAIN()\nTobs: the observation time window right before the leading window (Tlead).\nTlead: the leading window right before the prediction window\nTpred: the window of prediction (where TIP is true or false according to the number of anmalies in the corresponding Tobs window)\n\nOutput arguments:\n\nTIPtime1: a 1-d datetime array for TIP_valid\nTIP_valid: a 1-d logical array indicating whether the TIP is valid or not.\ndates_TIPvalid_st: Returns the datetimes of where the TIP have a meaningful true/false.\ndates_TIPinvalid_st: Returns the datetimes of where the TIP have a meaningless false. (If TIP is true, then the day should always be valid)\n\nAbout the meaningful and meaningless ‘false’, see the comments in anomalyind()\nRecalling that sum of AIN is the sum of anomaly index calculated in the moving time window of length Tobs, and the dates DateTimeSAT(sum_AIN_valid) denotes the end day of Tobs where at least one of the anomaly index in the Tobs window is meaningful, we have the following example where Tlead = 9, Tobs = 7, and Tpred = 3, for explicitly demonstrates how the TIP’s valid times are calculated:\nsum_validateIndex_all_a_dti\n              '1100111011000001010010000000001010000000' (for example) \nDateTime_dti   tttttttttttttttttttttttttttttttttttttttt|\nDateTimeSAT          tttttttttttttttttttttttttttttttttt|\nsum_AIN_valid        1111111111111111111110001111111110|\ndt_AIN_valid         ttttttttttttttttttttt   ttttttttt |\n               |Tobs ||&lt;--a---&gt;|                       |&lt;--b-----&gt;|\nTIPtime                        tttttttttttttttttttttttttttttttttttt\nTpred moving window            |c|                              |c|\n                               | the same length as DateTimeSAT |\nTIPvalid_0                     123456789........................\n                                \\\\\\\\\\\\\\\nTIPvalid_1                       3456789..........................\n\nTherefore, \ndt_TIPvalid = unique(TIPtime([1:3,2:4,3:5,....]))\n\n% t denotes a datetime object\n% a = Tlead+1 = idinc2predstart\n% b = Tlead+Tpred = idinc2predend\n% c = Tred\n% dt_AIN_valid is DateTimeSAT(sum_AIN_valid), and sum_AIN_valid is a.k.a Tobs_TF.\n% TIPvalid_0 (_1) is a.k.a. TIP_TF_0 (_1)\n\n\neqktip1\n[EQK,TIP, TIPtime] = eqktip1(eqMR,eqDateTime, DateTimeSAT,vlSAT, ...\n                   Tthr_iMod,Tlead_iMod,Tpred_iMod, Mc_iMod,Rc_iMod)\nprovides 1 dimensional logical array of target earthquakes (EQK) and Time of Increased Probability (TIP), corresponding to the 1-d datetime array TIPtime.\nInput arguments:\n\neqMR: a N by 2 array of all-combination of model magnitudes and radii of detection, with the first column being magnitude and second column the radius of detection.\neqDateTime: a N by 1 cell array. Each cell contains the datetime of target earthquakes satisfying the corresponding row of eqMR; i.e., being larger than eqMR(i,1) and within eqMR(i,2).\nDateTimeSAT, vlSAT: see sumanomalyind.\nTthr, Tlead, Tpred: see dt_TIP_true.\nMc_iMod: the current model magnitude.\nRc_iMod: the current model radius of detection.\n\nOutput arguments:\n\nEQK: the M-by-1 logical array for whether there is/are target earthquakes in the day.\nTIP: an M-by-1 logical array of Time of Increased Probability\nTIPtime: an M-by-1 datetime array paired with the TIP and EQK array\n\nSee also:\n\n[~,eqMR,eqDateTime] = isearthquakeinrange(...) in molscore\n[DateTimeSAT,vlSAT] = sumanomalyind(...) in molscore\n\n\n\nget_modelparam\nUse [var1, var2, ...] = get_modelparam(BestModels, 'name1', 'name2',...) to get specific model parameters uniquely. BestModels is the output of bestmodel().\nExample:\n\nTpreds, Tleads = get_modelparam(BestModels, 'Tpred', 'Tlead')\n\n\n\njointstation\njointstation calculates hit rates, alarmed rates, and spatial probability.\nExample:\nWhen it is applied for calculating the hit rates of the training phase:\nHitRates_trn = jointstation(BestModels,BestModelNames,idPermute,...\n             sum_tsAINs,sum_validateInds,DateTime_dti,...\n             CWBcatalog,'CalculateHitRate',true);\nWhen it is applied for calculating the forecasting probabilities:\n[HitRates_frc, AlarmedRates_frc, SpatialProbability, xLon, yLat, ...\n    validStationTime, ProbTime, TIP3, TIPvalid3, EQKs, Other]...\n    = jointstation(BestModels,BestModelNames,idPermute,...\n         sum_tsAINs,sum_validateInds,DateTime_dti,...\n         CWBcatalog,'CalculateHitRate',true,...\n         'CalculateAlarmedRate',true,'CalculateProbability',HitRates_trn,...\n         'StationLocation',StationLocation, 'WithExtra', true);\nKeyword Arguments:\n\n‘CalculateHitRate’: Whether to calculate the hit rates. Default is false.\n‘CalculateAlarmedRate’: Whether to calculate the alarmed rates. Default is false.\n\nIf ‘CalculateProbability’ is true, ‘CalculateAlarmedRate’ will be automatically set to be true since alarmed rates are essential to probability calculation.\n\n‘CalculateProbability’: Whether to calculate the spatial probability. Default is false.\n‘StationLocation’:\n\nA J by 3 table with the column names being ‘format’, ‘Lon’, ‘Lat’ and row names (i.e. StationLocation.Properties.RowNames) the station codes (e.g. ‘TW’, ‘CS’,…) of the total J stations.\nIf ‘CalculateAlarmedRate’ is true, ‘StationLocation’ must be specified; otherwise it is impossible to obtain alarm rates.\nDefault is 0.\n\n\nInput arguments:\n\nBestModels: A J-by-1 cell array containing the best models of total J stations. In each cell there is a table model parameters.\nBestModelNames: An J-by-1 cell array containing station names corresponding to BestModels (also J-by-1 cell array).\nidPermute: The randomly permuted indices for the best models. See bestmodel().\nsum_tsAINs: A J-by-1 cell array with each cell corresponding to BestmodelNames. See loadAIN().\nsum_validateInds: A J-by-1 cell array with each cell corresponding to BestmodelNames. See loadAIN().\nDateTime_dti: A T by 1 datetime array for the time series in sum_tsAINs and the sum_validateInds.\nCWBcatalog: A table of earthquake catalog. You may load CWBcatalog using only1field([dir_catalog filesep 'catalog.mat']).\nWithExtra: Output an additional struct of supplementary data as the Other variable.\n\nOutput arguments:\n\nHitRates, AlarmedRates: M by 1 array, being the hit rates (alarmed rates) of each combination of best models. M is the amounts of total combinations (the totalM in bestmodel()). They are AlarmedRateForecasting and HitRatesForecasting of molscore3’s output. AlarmedRates(i) can be a number or NaN (when 0/0).\nSpatialProbability: A S by T array of the temporal-spatial forecasting probabilities. It is the output variable Probability of molscore3().\nxLon (yLat): The longitudes (latitudes) of all spatial points as a S by 1 array. It is the output variable ProbabilityLon (ProbabilityLat) of molscore3().\nvalidStationTime: A T by J table of the ratio of valid models each day each station. This is for plotProbability(), that the ratio will be demonstrated as gradient color in the marker of each station. If the ratio is zero, the marker on map will be hollow. It is the output variable validStationTime of molscore3().\nTIP3: A S by T TIP array for the first model (out of the total M models). Since the first element of each cell in idPermute is always 1, indicating the best model, TIP3 is essentially the TIP array calculated according to the best model parameter.\nTIPvalid3: A spatial-temporal logical array indicating whether a point (s,t) of TIP true or false is meaningful or not. This is also a S by T array.\nProbTime: A 1 by T datetime array for TIP3, TIPvalid3 and SpatialProbability. This is the ProbabilityTime of molscore3’s output.\nEQKs: The list of target earthquake, with each column\n\ntime, Lon, Lat, Depth, Mag: The time, longitude, latitude, depth and magnitude (\\(M_L\\)) of the target earthquake.\nInStation: Indicates the target earthquake is of which station.\nEqkDist: The distance between the station (as specified by InStation) and hypocenter of the target earthquake. Also see simpleStationEQKdist3D.\n\nOther: The additional output when ‘WithExtra’ is true.\n\nOther.nEQK: The number of target earthquakes for each model in forecasting phase.\nOther.areaTIP: The total area (spatial + temporal, i.e., sum(TIP_valid_area)) of TIP for each model in forecasting phase. See TIPspatialtemporal and TIPArea.\nOther.nEQK .* HitRates is the number of hitted earthquakes for each model in this forecasting phase.\nOther.areaTIP .* AlarmedRates is the total amount of alarmed TIP area (i.e., sum(TIP_true_area)) for each model in this forecasting phase.\nNoted that it is nonsesnse to set ‘WithExtra’ to be true when ‘calculateHitRate’ and ‘calculateAlarmedRate’ are false.\n\n\n\n\nloadAIN\n[sum_tsAINs,sum_validateInds,DateTime_dti,AthrList] =\nloadAIN(dir_tsAIN,BestModelNames,TimeRange)\nload tsAIN, calculate the summation of anomaly index of each day, and truncate the time series to TimeRange.\nIf class(BestModelNames) == 'char', for example, ‘CS’, the output sum_tsAINs and sum_validateInds are the 10 by 1 cell array directly, instead of a M by 1 cell array inside the J by 1 cell array where J = 1.\nInput arguments::\n\ndir_tsAIN: the directory for the saved AIN data. See anomalyind().\nBestModelNames: an J-by-1 cell array containing station names corresponding to BestModels (also J-by-1 cell array).\nTimeRange: a two-element datetime array.\n\nOutput arguments::\n\nsum_tsAINs: a J-by-1 cell array with each cell corresponding to BestmodelNames. In each cell there is a 10-by-1 cell corresponding to the list of \\(A_{thr}\\) (AthrList = 1:10), being the timeseries of the summation of anomaly index of each day.\nsum_validateInds: a J-by-1 cell array with each cell corresponding to BestmodelNames. In each cell there is a 10-by-1 cell corresponding to the list of \\(A_{thr}\\) (AthrList = 1:10), being the summation of the indicators for the valid statistical indices of each day.\n\n\n\nmodparam\nIn GEMS-MagTIP, model parameters defines TIP and target earthquakes (EQK). [PredParam,varargout]=modparam() generate the whole set of model parameters that are going to be used in the training phase by molscore.\nKeyword Arguments:\n\n‘Rc’: Radius (range) of detection in unit kilometer. Default is [20:10:100])\n‘NthrRatio’:\n\nThe ratio threshold to be converted to the number of anomalous statistic index every day.\n‘NthrRatio’ should be calculated automatically in molscore() according to the maximum possible number of statistic indices among the anomaly index calculated by anomalyind().\nNthr is the threshold (integer) for the number of anomalous statistic indices each day.\nDefault is [0.01, 0.99], which is for the situation where the maximum possible Nthr is \\(\\leq 2\\) (i.e., to be [0, 1]). If you have the maximum possible Nthr to be \\(\\leq 3\\) (i.e, Nthr = [0 1 2]), ‘NthrRatio’ should be assigned to be [0.01, 0.49, 0.99] for example.\n\n‘Ptthr’: Ptthr defines Tobs through Ptthr = Tthr/Tobs. Default is [0.1:0.1:0.5].\n‘Tobs’: The length of observation moving window. Default is [5:5:100];\n‘Tpred’: The length of prediction moving window.\n‘Tlead’: The length of leading window, the time gap that is for the period of silent (no-anomaly) right before big earthquakes.\n\nDefault is [0:5:100].\n\n‘Mc’: The magnitude threshold. Default is 5, which means only events of \\(M_L \\geq 5\\) will be considered as target earthquakes.\n‘Test’:\n\nIf true or 1, then the PredParam is reduced to 1000 randomly picked models from the default combination.\nIf it is a positive integer N other than 1, the predParam is reduced to N randomly picked models.\nDefault is 0.\n\n‘Seed’: the seed for the random selection while ‘Test’ is enable.\n\nSeed must be a nonnegative integer seed less than 2^32.\nIf seed is less than zero, the random selection has its result different everytime.\n\n\nOutput:\n\nPredParam: The GEMSTIP/MagTIP models of total 8 free parameters: G = [Mag,Rad,NthrRatio,Athr,Tthr,Tobs,Tpred,Tlead].\n\nExamples: - [PredParam, columnNames] = modparam('OutputFormat','double'); - [PredParam_table] = modparam('OutputFormat','table');\n\n\nshift2TIPtime\n[dt_true_in_TIP, TIPtime] = shift2TIPtime(DateTimeSAT,Tobs_TF,Tlead,Tpred) gives the date time array in the domain of TIPtime, where the trues in TIPtime are defined in Tpred window according to the data in Tobs window. Tobs_TF:\n\ntrues or falses according to the data in Tobs moving window.\nthese true-falses should be exactly the same size of DateTimeSAT, where DateTimeSAT is the moving-window’s time tags (at the last day of the moving time window)\ne.g., vlSAT&gt;=Tthr_iMod\ne.g., logical(MovingWindowSum(sumvalidateIndexalladti,Tobs))\n\n\n(these examples are taken from see dtTIPtrue.m and dtTIPinvalid.m)\n\ndt_true_in_TIP: the corresponding trues in the TIP time domain.\n\n\nsortModelBy\nSort model names by a certain column value. Example: [sortedModelNames, I] = sortModelBy('Lat','descend',ModelNames,TheTable);\n\n\nsumanomalyind\n[DateTimeSAT,vlSAT] = sumanomalyind(DateTime_j,sum_tsAIN_k,Nthr_array,Tobs_i) calculate sum of anomaly day (vlSAT) and its corresponding datetime series (DateTimeSAT). It is simply the moving-window sum of the sum_tsAIN_k timeseries, where the moving-window length is Tobs_i; in which, i stands for \\(i_{th}\\) model, j for \\(j_{th}\\) station, and k for \\(k_{th}\\) threshold \\(A_{thr}\\). Of coursely, the number of elements of the output timeseires (DateTimeSAT) will be Tobs_i - 1 less than the input timeseries (DateTime_j or DateTime_dti); i.e., length(sum_tsAIN_k) - length(vlSAT) =  Tobs_i - 1.\nInput arguments:\n\nDateTime_j: the datetime array for sum_tsAIN.\nsum_tsAIN_k: the sum of anomaly statistical indices each day.\nNthr_array: The thresholds for sum_tsAIN_k calculated according to NthrRatio. Nthr is known as the threshold of the total daily amount of anomaly statistical indices.\nTobs_i: the observation window of model i.\n\nOutput arguments:\n\nDateTimeSAT: M-by-1 datetime array for sum of anomaly days\nvlSAT: M-by-1 double array for the values of sum of anomaly days (the anomaly days is summed in the moving window of Tobs)\n\nSee also:\n\nconvAIN for more details about sum_tsAIN_k.\n\n\n\ntruncateTIPtoSAT\nInternal API associated with the truncation of TIP array to the datetime array for the sum of anomaly indices."
  },
  {
    "objectID": "doc_library/index.html#format",
    "href": "doc_library/index.html#format",
    "title": "Library",
    "section": "Format",
    "text": "Format\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\nfmt\nfmt is a class that\n\nstores all constant names\nstores all constant variables\n\nthat enables you to modify or extend some contents without breaking other functionalities.\nGEMS-MagTIP depends on fmt to load a variety of intermediate data, including earthquake catalog, station information table and the input data of the standard format. fmt save constant names and variables as properties (Constant) that they can be available in global scope. fmt also have static methods for acquiring information such as the column indices indicating the time vectors and recorded values of the input data of different types.\nproperties (Constant):\n\nInfoFileName_molscore = '[MolchanScore]Information.mat': name to the intermediate file in the session of training (model optimization)\nInfoFileName_anomalyind = '[tsAIN]Information.mat': name to the intermediate file in the session of calculating anomaly indices\nInfoFileName_jointstation = '[JointStation]Information.mat': name to the intermediate file in the joint-station method session\nInfoFileName_statind = '[StatisticIndex]Information.mat': name to the intermediate file in calculating Statistic Index\ncatalogFileName = 'catalog.mat': file name to the earthquake catalog\nstationLocationFileName = 'station_location.mat': name to the file of station information table\ntag_upperlowerthreshold = 'ULthr': tag for upper- and -lower threshold defined by Athr\ndatestrFormat = 'yyyymmdd': the format for converting datetime to string tags (dt)\ndatetimeInputFormat = 'yyyyMMdd': the format for converting date strings (with tag dt) to datetime\ndatetimeIncrement: the increment of datetime between two consecutive files of the same station and type.\nLatitudeLimit = [21.5 26]: latitude limits of the Taiwan area\nLongitudeLimit = [118 122.5]: Longitude limits of the Taiwan area\ndatatype_mag_1 = {'mFull', 'full'}: \"type\" tag for the full field geomagnetic data (old geomagnetic stations from 2006; ‘full’ is for backward compatibility)\ndatatype_mag_3 = {'mTri', 'tri'}: \"type\" tag for the 3 component geomagnetic data (new geomagnetic stations from 2020; ‘tri’ is for backward compatibility)\ndatatype_GEMS_HJ: \"type\" tag for the data of Hong-Jia Chen 2018\ndatatype_GEMS: \"type\" tag for the primitive of Geoelectric data\n\nmethods (Static):\n\ncolindex2data(what_type): returns column indices to time and data part of the loaded matrix. Example: [colind_time, colind_data] = colindex2data('GEMS0')\nfilterRange(filter_tag): returns two values indicating the lower and upper limit of the filter, in the unit of Hz. Example: fmt.filterRange(ULF_A).\ndatasampfreq(what_type): returns the expected Sampling Frequency of a specific file/data type. Example: fs = datasampfreq('GEMS0'). You can obtain expected data points of the day by supposedpts = fs*86400.\nfmtfieldname = datatype_fieldname(what_type): returns the field name for fmt that you can fmt.(fmtfieldname)."
  },
  {
    "objectID": "doc_library/index.html#plotting-functions",
    "href": "doc_library/index.html#plotting-functions",
    "title": "Library",
    "section": "Plotting functions",
    "text": "Plotting functions\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\nplotCB\nPlot confidence boundary Make sure xpt0 and Dcb_max are both N by 1 array.\n\n\nplotEQKTIP1\nplotEQKTIP1(dir_tsAIN,dir_molchan,dir_catalog,dir_output) plot one-dimensional TIP time series for each station with target earthquakes (EQK) scattered over the diagram; the results are saved as png files in dir_output.\nKeyword Arguments:\n\n‘ShowTrainingPhase’: Whether to show the EQK and TIP on the plot. Default is false.\n‘scatter’: Set it true to add an additional layer of scattering points of the same color on the top of every TIP==1. This option allows better visual inspection on whether target earthquakes lay in the area of TIP==1 or not. Default is false.\n‘Rank’: Choose the model by fitting degree ranking for defining EQK and TIP. Default is 1 (plot the EQK and TIP that are defined by the rank 1 model).\n‘OnlyStations’: Specify only a subset of station to be displayed on the plot; for example, for 'OnlyStations',{'MS','TW'} only the results of these two stations will be displayed. In default, results of all stations will be displayed.\n‘datetimeTickArguments’: Manually define the datetime format of the X tick labels. For example, for 'datetimeTickArguments', {\"yy' mmm.\", 1,'months'} the datetime 2012-Nov-12 will be printed as “12’ Nov.”. For more information, see datetime_ticks().\n‘TargetPattern’: See the documentation in plotProbability().\n\n\n\nplotEQKTIP3\nLike plotEQKTIP1, but expand the 3D TIP array into a 2D diagram by squashing spatial coordinates (latitude and longitude) into one.\n\n\nplotFittingDegree\nplotFittingDegree(dir_jointstation,dir_catalog,dir_png) gives fitting degree analysis and molchan diagrams for each training-forecasting phase pair according to the results from molscore3.\n\n\nplotProbability\nplotProbability(dir_jointstation,dir_catalog,dir_out) plots two-dimensional probability forecasting maps; the results are saved as png files in dir_output.\nKeyword Arguments:\n\n‘LongitudeLimit’: The longitude limits of the displayed map. Default is [119 122.5].\n‘LatitudeLimit’: The latitude limits of the displayed map. Default is [21.5 26].\n‘TimeRange’: Manually assign time ranges or specific dates that must lay in the forecasting phase to plotting probability forecast. If not set, the probability forecast of every available dates will be plotted. The assigned datetime array must be either:\n\nAn N by 2 datetime array specifying N ranges at one time.\nAn N by 1 datetime array specifying N days to be plot.\n\n‘PlotEpicenter’: Whether to plot the epicenter(s) of the target earthquakes on the map. Default is 0.\n\nplotEpicenter, 1: plot target events only (those in Rc).\nplotEpicenter,'all': plot all events even when they are not in Rc.\n\n‘Rigorous’: Whether to drop (ignore) the probability forecasts that are not in the range of the forecasting phases. Default is true. Generally the leading time window (Tlead) is different among models, and the probability can be calculated as far as the Tlead of at least one model covered. However, for the dates out of the forecasting phase, only part of the models are applied thus the probability forecast is weaker.\n‘TargetPattern’: the pattern for filtering the files in dir_jointstation. Default is to look up all files that fits the pattern “[JointStation].mat”. For example, you can manually specify it as ”[ULF*A]” to give plots of that have the tag ULFA in the file name only. The pattern should always begin with “” and the last cahracter can never be ””. For multiple filtering at once (e.g., '*[ULF_B]*[Tpred-1]'), join the pattern with “” and the order is important.\n\n\n\nplot_Rc\nPlot radius of detection around the station.\n\n\nplot_dataoverview\nplot_dataoverview(dir_stat, dir_catalog) plot an overview of all data. Keyword Arguments:\n\n‘SaveFigureTo’: the output path\n‘BackgroundColor’: Background color; default is white ([1,1,1])\n‘DatetimeTicks’: The format of datetime ticks on the x-axis.\n\nDefault is {'yyyy-mm',6,'Months'}, which means tick labels are in the format of yyyy-mm and interspaced every 6 months.\n\n\n\n\nplot_epicenter\nplot epicenter [scatter_handle, axes_handle] = plot_epicenter(CWBcatalog,[ax], kwargs...)\nExample\nSLoc = only1field(fullfile(dir_catalog, fmt.stationLocationFileName));\ncheckcatalog(dir_catalog)\nCWBcatalog = only1field(fullfile(dir_catalog, fmt.catalogFileName));\nCWBcatalog = eventFilter(CWBcatalog, 'Magnitude', 5, 'TimeRange', '20220601-20221002');\n\nfigure;\n[sc1, ax1] = plot_station(SLoc,'PlotFunction','map', 'MarkerFaceColor', 'none', 'MarkerEdgeColor', '#D95319', 'StationCode', false); % plot all station\nhold(ax1, 'on');\nplot_epicenter(CWBcatalog, ax1, 'PlotFunction','map'); % plot epicenters\nset(gcf, 'Position', [100 100 792 669]);\n\n\nplot_station\nplot map and station. See plot_epicenter."
  },
  {
    "objectID": "doc_library/index.html#others",
    "href": "doc_library/index.html#others",
    "title": "Library",
    "section": "Others",
    "text": "Others\n\n\n\n\n\n\nDocstring\n\n\n\n\n\n\n\n\nMolchan_CB\n[molt_cb,moln_cb] = Molchan_CB(N,alpha) gives the confidence boundary in molchan diagram, where [molt_cb,moln_cb] are the points defining the boundary on the alarmed-rate-against-missing-rate phase plane.\nInput Arguments:\n\nN: total number of target events/earthquakes\nalpha: 1-alpha is the confidence level. For example, alpha=0.05 means 95% confidence level.\n\nOutput Arguments:\n\nmolt_cb: values corresponding to the alarmed rate\nmoln_cb: values corresponding to the missing rate\n\nHint:\n\nCalculate the \\(D\\) (fitting degree) values by Dcb = 1 - molt_cb - moln_cb\n\n\n\naskquestion\nExample\naskquestion('Hello, would you like to continue? [Y/N]', @(x) strcmp(x, 'Y'))\nHello, would you like to continue? [Y/N]Y\n\nans =\n\n  logical\n\n   1\n\n\ncalcFittingDegree\ncalcFittingDegree(jpathlist) according to the given files (jpathlist) provides the overall alarmed rate, missing rate that allows the calculation of the overall fitting degree. Make sure to provide correct input list of the [JointStation] variable , for example, those have the same ID and are not overlapped in forecasting time interval for each group; otherwise the calculated fitting degree can be unreasonable.\nExample:\ndir_png = 'MyResearch/Figures';\njpathlist = datalist('[JointStation]ID[ou7ud]prp[ULF_B]*.mat', dir_jointstation).fullpath;\n[AlarmedRate, MissingRate, xticklabel, EQKs, TIP3s, TIPv3s,TIPTimes,LatLons] = calcFittingDegree(jpathlist);\nFittingDegrees = 1 - AlarmedRate - MissingRate;\nplotEQKTIP3(dir_png,prp_i, xlabels, EQKs, TIP3s, TIPv3s,TIPTimes, LatLons);\nInput Arguments:\n\njpathlist: a cell array of the full paths of [JointStation] files that are produced by molscore3. You can simpliy obtain the path list by jpathlist = datalist('[JointStation]ID[ou7ud]*prp[ULF_A]*slc[Tpred-10]*.mat',dir_jointstation).fullpath;\n\nKeyword Arguments:\n\n‘GroupTag’: The tag for grouping the files in jpathlist.\n‘GroupNames’: Results are calculated separately according to the assigned group names; alarmed rate, missing rate and so on are only calculated if the file name contains the assigned group names. For example, for ...,'GroupNames',{'Tpred-1', 'Tpred-5'},'GroupTag', 'slc',..., only the files with their names containing tag ‘slc[Tpred-1]’ and ‘slc[Tpred-5]’ are selected, and the results of those being ‘Tpred-1’ and ‘Tpred-5’ are separately calculated. That is, the output xlabel is {'Tpred-1', 'Tpred-5'} and other output arguments (e.g. AlarmedRate) are all cell array of the same dimension as xlabel containing the results of the groups that are calculated separately.\nNoted that You cannot assign ‘GroupName’ without assigning ‘GroupTag’, but assigning ‘GroupTag’ without assigning ‘GroupName’ is OK, in this case the group names will automatically generated and sorted.\n\n\n\ncheckcatalog\n[isvalid, msg] = checkcatalog(dir_catalog) check if catalog.mat/csv exist in dir_catalog, and convert the catalog.csv to catalog.mat. After successfully create catalog.mat, the original catalog.csv will be moved to the folder ‘original_csv’.\nIf the catalog.csv does not meet the required format, error will occur. The catalog.csv has to suffice the following condtions:\n\nThe ‘time’ variable should be in the following format: ’yyyy/MM/dd\n\nHH:mm’.\n\nOther variables except ‘time’ should belong the class of ‘double’.\nBasicaly the following headers (column names),\n\n{‘time’,‘Lon’,‘Lat’,‘Mag’,‘Depth’}, have to exist.\nAliases for the column names in the catalog.csv are allowed; see the Aliases section below.\nKeyword arguments: 'OverwriteOriginal', false: The csv files in ‘original_csv’ will not be overwritten. Set 'OverwriteOriginal', true if you have version control.\nAliases: For convenience, aliases of the column name of an variable in catalog.csv will be automatically converted:\n\nFor earthquake magnitudes, the header of either {‘Magnitude’, ‘magnitude’, ‘ML’} will be automatically converted to ‘Mag’.\nFor depths, the header of either {‘depth’, ‘dep’, ‘Dep’} will be converted to ‘Depth’.\nFor longitude and latitude, either {‘lon’, ‘longitude’, ‘Longitude’},\n\n{‘lat’, ‘latitude’, ‘Latitude’} will be converted to ‘Lon’ and ‘Lat’, respectively.\nFor convenience, in catalog.csv, if the event time is written in separated two columns ‘date’ and ‘time’, with format ‘yyyy-mm-dd’ (or ‘yyyy/mm/dd’) for ‘date’ and ‘hh:MM:ss’ (or ‘hh:MM’), they will be merged as a single ‘time’ variable sufficing the format mentioned before.\n\n\ncheckstation\n[isvalid, msg] = checkstation(dir_catalog) check if station_location.mat/csv exist in dir_catalog, and convert the station_location.csv to station_location.mat. After successfully create station_location.mat, the original station_location.csv will be moved to the folder ‘original_csv’.\nIf the station_location.csv does not meet the required format, error will occur. The station_location.csv has to suffice the following condtions:\n\nThe ‘time’ variable should be in the following format: ’yyyy/MM/dd\n\nHH:mm’.\n\nOther variables except ‘time’ should belong the class of ‘double’.\nBasicaly the following headers (column names),\n\n{‘code’,‘format’,‘Lon’,‘Lat’} have to exist. In which,\n\n‘code’ is the code for the station, whereas ‘format’ is the full name of the station. For example, ‘MS’ (code) corresponds to ‘馬仕’ (format).\n‘Lon’ and ‘Lat’ are longitude and latitude of the station respectively.\n\nAliases for the column names in the station_location.csv are allowed; see the Aliases section below.\nKeyword arguments: 'OverwriteOriginal', false: The csv files in ’original*csv’ will not be overwritten. Set 'OverwriteOriginal', true if you have version control. Aliases: For convenience, aliases of the column name of an variable in station*location.csv will be automatically converted:\n\nFor longitude and latitude, either {‘lon’, ‘longitude’, ‘Longitude’},\n\n{‘lat’, ‘latitude’, ‘Latitude’} will be converted to ‘Lon’ and ‘Lat’, respectively.\n\n\nchkans\nCheck the answer in the interaction command-line interface in startup0.m\n\n\nconstructMolInfo\nconstructMolInfo(dir_molchan,InfoId) construct the ‘[MolchanScore]Information.mat’ according to existing [Molchanscore]___.mat files if possible. Use this function only when you are instructed by error messages.\nExample constructMolInfo('./var-output/MolchanScore-O04-Cfl_local', 'OT0qPb')\n\n\nderive_type\nderive_type derives station type from tag stn[...].\n\n\ndirselectassign\ndirselectassign(var_names...) prompts user to select directories in a dialog box, and assigned the selected path to workspace with default variable name. If a variable with the same name as the default name has already in the workspace, its assignment will be ignored (i.e. its dialog box won’t pop out). This is a tool for convenience. You can always assign directories explicitly to variable with any name you like.\nExample:\n\nFour windows will pop out one by one allowing you to assign directories to variables dir_stat, dir_tsAIN, dir_molchan, dir_jointstation:\ndirselectassign('dir_stat','dir_tsAIN','dir_molchan','dir_jointstation');\n(Read the printed message in the Command Window)\nTotal 7 windows will pop out one by one allowing you to assign directories to the variables with default names dir_stat, dir_tsAIN , dir_molchan, dir_jointstation, dir_data, dir_catalog, dir_toolbox:\ndirselectassign();\n(Read the printed message in the Command Window)\n\n\n\nfft_of_the_day\nFourier transform of the one-day data.\n\n\nfitting_degree_summary\nfitting_degree_summary gives the object for fitting-degree plot.\n\n\nformatForecastingPhase\n[frcphase] = formatForecastingPhase(frcphase,trnphase) is the function for converting the argument that the keyword option ‘ForecastingPhase’ takes.\n\n\ngenID\nGenerate trial identifier.\n\n\ngetRcs\nSRc = getRcs(dir_molchan,targetpattern) returns unique Rc as a struct with field names being the station code (stn[…]). Example\ntargetpattern = sprintf('[%s]stn*.mat', get_tags(fmt.InfoFileName_molscore, '', 'once'));\nSRc = getRcs(dir_molchan,targetpattern)\n\n\nloadSheet\nloadSheet(filepath,whatisthis) is deprecated; use checkcatatlog and checkstation instead.\n\n\nmkdir_default\nmkdir_default creates/makes folders by default and return their directories with default variable names. The default structure is:\n                   variable           default folder name\n    ╔═ dir_main ═╤═══════════════════════════════════════╗\n    ║            ├─dir_stat         =   'StatisticIndex' ║\n    ║            ├─dir_tsAIN        =   'tsAIN'          ║\n    ║            ├─dir_molchan      =   'MolchanScore'   ║\n    ║            └─dir_jointstation =   'JointStation'   ║\n    ╚════════════════════════════════════════════════════╝\nExample:\n[dir_stat, dir_tsAIN, dir_molchan, dir_jointstation] =\n  mkdir_default(fullfile(pwd,'output_var'))\n[dir_stat, dir_jointstation] =\n  mkdir_default(fullfile(pwd,'var-output'), 'Directories', {'StatisticIndex'; 'JointStation'})\n\n\nmodeldiscard\nFilter models negatively (modeldiscard)\n\n\nmodelselect\nFilter models positively (modelselect)\n\n\nprpfunctions\nprp_list = prpfunctions() returns the list of existing preprocessing functions that you can apply (those located in the same directory (namely, dir_prp = 'src/preprocess') as the function no). Noted that those under the sub-directories of dir_prp won’t be listed.\n\n\nrenamecols\nrenamecols(alias, O) rename the column name that matche either in alias of the table O to the newname.\n\n\ntabledragandfill\nA small tool that fill the empty cells of a column by the most recent non-empty value (just like ‘click, drag, and fill’ in the excel).\nExample: CWBcatalog = tabledragandfill(CWBcatalog, colname1, colname2, ...)"
  },
  {
    "objectID": "doc_tutorial/index.html",
    "href": "doc_tutorial/index.html",
    "title": "Tutorial",
    "section": "",
    "text": "GEMS-MagTIP relies on the following toolboxes; type license('inuse') in matlab command line or ver to list the toolboxes currently available on your machine.\nToolbox in-use:\n\nMATLAB Version 9.11 (R2021b)\nMapping Toolbox Version 5.2 (R2021b)\nParallel Computing Toolbox Version 7.5 (R2021b)\nSignal Processing Toolbox Version 8.7 (R2021b)\nStatistics and Machine Learning Toolbox Version 12.2 (R2021b)\n\n\n\n\nGEMS-MagTIP depends on okatsn/toolbox and CGRG-lab/GEMS-MagTIP-insider.\nYou have to add these dependencies to path every time before running your scripts, as follows\n\n\nCopy CGRG-lab/GEMS-MagTIP-insider to your local drive (e.g., GEMS-MagTIP-insider) and add the source code inside to path:\ndir_src = 'GEMS-MagTIP-insider/src';\naddpath(genpath(dir_src));\n\n\n\nCopy okatsn/toolbox to the main directory (e.g., GEMS-MagTIP-insider/toolbox) and add the source code inside to path:\ndir_toolbox = 'GEMS-MagTIP-insider/toolbox';\naddpath(genpath(dir_toolbox));"
  },
  {
    "objectID": "doc_tutorial/index.html#requirements",
    "href": "doc_tutorial/index.html#requirements",
    "title": "Tutorial",
    "section": "",
    "text": "GEMS-MagTIP relies on the following toolboxes; type license('inuse') in matlab command line or ver to list the toolboxes currently available on your machine.\nToolbox in-use:\n\nMATLAB Version 9.11 (R2021b)\nMapping Toolbox Version 5.2 (R2021b)\nParallel Computing Toolbox Version 7.5 (R2021b)\nSignal Processing Toolbox Version 8.7 (R2021b)\nStatistics and Machine Learning Toolbox Version 12.2 (R2021b)\n\n\n\n\nGEMS-MagTIP depends on okatsn/toolbox and CGRG-lab/GEMS-MagTIP-insider.\nYou have to add these dependencies to path every time before running your scripts, as follows\n\n\nCopy CGRG-lab/GEMS-MagTIP-insider to your local drive (e.g., GEMS-MagTIP-insider) and add the source code inside to path:\ndir_src = 'GEMS-MagTIP-insider/src';\naddpath(genpath(dir_src));\n\n\n\nCopy okatsn/toolbox to the main directory (e.g., GEMS-MagTIP-insider/toolbox) and add the source code inside to path:\ndir_toolbox = 'GEMS-MagTIP-insider/toolbox';\naddpath(genpath(dir_toolbox));"
  },
  {
    "objectID": "doc_tutorial/index.html#getting-started",
    "href": "doc_tutorial/index.html#getting-started",
    "title": "Tutorial",
    "section": "Getting Started",
    "text": "Getting Started\nThe main functions of GEMS-MagTIP take directories that contains intermediate data (those .mat files) as input arguments, and output data in the assigned directory.\nHere is the minimal example of the chain of main functions:\n\nPrepare your data\nYou have to prepare/update the following data:\n\nearthquake catalog\ngeo-electric data of standard format\ngeo-magnetic data of standard format\n\n\nEarthquake catalog and station information\nPlease download or update catalog of events \\(M_L \\geq 5\\) from GDMSN, and move it to spreadsheet/catalog.csv. The spreadsheet/station_location.csv specifies the location of every station, which is included in the copy of GEMS-MagTIP-insider.\n\nKeypoints\n\nThe headers (column names) for catalog.csv should be ‘time’, ‘Lon’, ‘Lat’, ‘Depth’, and ‘Mag’.\nThe headers for station_location.csv should be being ‘code’, ‘format’, ‘Lon’, ‘Lat’ for station_location.csv.\nThe order of column names can be arbitrarily arranged, but the strings have to be exactly the same as above.\nTo update earthquake catalog, just put the updated table in csv to spreadsheet/catalog.csv with overwriting option and run checkcatalog(dir_catalog); if both catalog.mat and catalog.csv are in the directory dir_catalog, catalog.mat will be overwritten by the new one converted from catalog.csv.\nTo update spreadsheet/station_location.csv, the procedure/workflow is the same as the previous point.\n\n\n\nSupported catalog format\n\nGDMSN form\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndate\ntime\nlat\nlon\ndepth\nML\nnstn\ndmin\ngap\ntrms\nERH\nERZ\nfixed\nnph\nquality\n\n\n\n\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n\n\n\n\n\nFree form\n\n\n\ntime\nLon\nLat\nDepth\nMag\n\n\n\n\n2020/8/10 06:41\n121.59\n23.81\n29.86\n3.41\n\n\n2020/8/10 06:29\n120.57\n22.18\n43.54\n3.02\n\n\n2020/8/10 06:14\n121.7\n22.17\n124.78\n4.13\n\n\n…\n…\n…\n…\n…\n\n\n\nhere is a partial view on an exemplary station_location.csv:\n\n\n\n\n\ncode0\ncode\nformat\ntype\nLat\nLon\nStartTime\nEndTime\n\n\n\n\nmissing\nZB\n知本\nGM\n22.7398\n121.065\n20201006\nmissing\n\n\nmissing\nXC\n新城\nGM\n24.0383\n121.609\n20201006\nmissing\n\n\nmissing\nSM\n日月潭\nGM\n23.881\n120.908\n20191008\nmissing\n\n\nmissing\nCN\n暨南\nGM\n23.9576\n120.928\n20221229\nmissing\n\n\nem3\nKUOL\n過嶺\nGE\n24.9629\n121.142\n2011-09-22\n9999-12-31\n\n\nem4\nHUAL\n華陵\nGE\n24.6745\n121.368\n2012-01-17\n9999-12-31\n\n\nem5\nTOCH\n頭城\nGE\n24.8435\n121.805\n2012-02-10\n9999-12-31\n\n\nem6\nENAN\n南澳\nGE\n24.4758\n121.785\n2012-02-15\n9999-12-31\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n\n\n\n\n\n\n\nData of the standard format\nConverting raw data into a standard format is crucial. The conversion involves verification of date-time, conduct projection for geo-electric data to NS-EW, format the file name for indexing, and etc..\nHere is the minimal script for converting raw data into the standard format:\ndir_gems_raw = 'data-raw/GEMSdat'; % raw GEMS data\ndir_mag_raw = 'data-raw/MAG'; % raw MAG data\ndir_data = 'data-standard'; % output directory\nconv_gemsdata(dir_gems_raw, dir_data, dir_catalog); \nconv_geomagdata(dir_mag_raw, dir_data); \n\n\n\n\n\n\nTip\n\n\n\nFeel free to organize files and folders under dir_data, or convert the same raw data twice, because in GEMS-MagTIP data loading relies on the name of the standard format and the conversion functions will handle duplicated files.\nSee standarddataname and write_data\n\n\nFor more information please refer the section Load raw data and convert it into a standard format.\n\n\n\nSetting Up Directory Paths\nAssigning directories for input/output data or variables is necessary before running any of the main function.\nFor example:\n% For windows, use backslash `\\`; for unix systems, use slash `/` in the path to directories.\ndir_catalog = 'GEMS-MagTIP-insider/spreadsheet'; \n        % directory of event catalog & station location\ndir_data = 'standard-data'; \n        % directory of geomagnetic timeseries of \"standard format\"\ndir_stat = 'var-output/StatisticIndex'; \n        % directory of statistic indices\ndir_tsAIN = 'var-output/tsAIN'; \n        % directory for storing anomaly index number (AIN)\ndir_molchan = 'var-output/Molchan'; \n        % directory for storing Molchan scores\ndir_jointstation = 'var-output/JointStation'; \n        % directory for the time series of EQK, TIP and probability\n\n\n\n\n\n\nTip\n\n\n\n\nYou can use mkdir_default to automatically generate empty directories for main functions.\nYou can use dirselectassign to assign directories via file explorer interface.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\ndir_catalog must contain catalog.csv or catalog.mat, and station_location.csv or station_location.mat.\ndir_data is the directory that contains GE or GM data of the standard format; see conv_geomagdata and conv_gemsdata for the conversion of raw data to the standard format.\n\n\n\n\n\nExecuting Main Functions in the Correct Order\nstatind(dir_data,dir_stat); \n\nanomalyind(dir_stat,dir_tsAIN); \n\nmolscore(dir_tsAIN,dir_catalog,dir_molchan); \n\nmolscore3(dir_tsAIN,dir_molchan,dir_catalog,dir_jointstation); \n\n\n\n\n\n\nTip\n\n\n\nstatind, molscore, and molscore3 have alternatives which run the same calculation in parallel. In most cases you can simply append _parfor (e.g., molscore3_parfor(...)) in the function name with no need to modify input arguments to do run in parallel. See statind_parfor, molscore_parfor, and molscore3_parfor.\n\n\n\n\nComprehensive Sample Script\nHere is a sample script “demo/demo_script.m” for the whole process.\n\n\n\n\n\n\nTip\n\n\n\nYou can run startup0.m and follows the instruction in the command window to add dependencies and assign input/output directories as described above.\n\n\n%% Convert Raw data to standard type\n% Load original data and save them as matfiles of the standard format\n\nconv_gemsdata(dir_gems_raw, dir_data, dir_catalog,'FilterByDatetime',datetime(2020,1,1)); % Convert raw GE data of timestamps after 2020-1-1 to standard format. \n% Assign 'FilterByDatetime' to save time when standard geomagnetic data out of the specified date-time range already exist. \n% Discard 'FilterByDatetime' to convert everything in the raw-data directory.\nconv_geomagdata(dir_mag_raw, dir_data,'FilterByDatetime',datetime(2020,1,1)); % The same as above but for the conversion of GM data.\n\n%% Calculate Statistic Index\nstatind_parfor(dir_data,dir_stat, ... % Load data in dir_data, save index in dir_stat\n    'Preprocess',{'ULF_A','ULF_B','BP_40','BP_35'}, ... % with 4 kinds of filtering\n    'SavePreprocessedData',false, ... % without saving filtered timeseries\n    'StatName', {'S', 'K', 'FI', 'SE'},  ... % the variable name for 'StatFunction'.\n    'StatFunction', {@skewness, @kurtosis, @fisherinformation, @shannonentropy}, ...\n    'FilterByDatetime',[datetime(2011,1,1), datetime(2022,12,31)]); \n% Assign 'FilterByDatetime' to calculate statistical indices only between 2011-1-1 and 2022-12-31. \n% Noted that standard format GE/GM data have to be available in this range, otherwise you will get NaN if data is missing (or not converted) in `dir_data`.\n\n\n%% Data overview\n% An overview of data avaliability/deficiency according to the results in dir_stat \nplot_dataoverview(dir_stat, dir_catalog);\n\n%% Calculate Anomaly Indices\nanomalyind(dir_stat,dir_tsAIN);\n\n%% Training\nmolscore_parfor(dir_tsAIN,dir_catalog,dir_molchan,... \n    'TrainingPhase', {calyears(3),datetime(2022,4,1);... % Use up to 3-years data before 2022-4-1 for model training.\n                      calyears(5),datetime(2022,4,1);... % Use up to 5-years data before 2022-4-1 for model training.\n                      calyears(7),datetime(2022,4,1);... % Use up to 7-years data before 2022-4-1 for model training.\n                      calyears(9),datetime(2022,4,1)},...% Use up to 9-years data before 2022-4-1 for model training.\n    'modparam',{'Test', 5000}); % Remember to disable 'Test' in a real run.\n\n%% Forecast and test\nmolscore3_parfor(dir_tsAIN,dir_molchan,dir_catalog,dir_jointstation,...\n    'OverwriteFile',true, ...\n    'ForecastingPhase', repmat([datetime(2022,4,2), datetime(2022,9,27)], 4,1));\n    % Manually assign forecasting phases. Typically the size of 'ForecastingPhase' should align with the size of 'TrainingPhase'."
  },
  {
    "objectID": "doc_tutorial/index.html#visualization-of-the-results",
    "href": "doc_tutorial/index.html#visualization-of-the-results",
    "title": "Tutorial",
    "section": "Visualization of the results",
    "text": "Visualization of the results\n\nPlot EQK-TIP Matching diagram\nEQK-TIP of each station:\n%% Plot EQK-TIP of each station\n\n% the output directory for the images\ndir_png = fullfile(dir_molchan,'png','EQKTIP'); % no need to mkdir\n\n% Plot TIP of individual stations as heatmap, \n% with target earthquakes (EQK) scattered on the top.\nplotEQKTIP1(dir_tsAIN,dir_molchan,dir_catalog,dir_png); %,...\n    'ForecastingPhase',calyears(1),'ShowTrainingPhase',1,'Rank',1,...\n    'ForceMagnitude',false, ...\n    'scatter',1); \n\n% remove the white space around the image.\ncropimg(dir_png,'SaveInplace',true);\n\n\n\nAn example of EQK-TIP plot.\n\n\n\nIn this figure, the match diagram of EQK and TIP defined by the model of first rank is demonstrated. The intervals of black color denotes the days where there is no data in \\(T_\\text{obs}\\) at all (i.e. this model is invalid at these time) and hence TIP cannot be calculated.\n\n\n\nPlot 2D EQK-TIP Matching diagram\nEQK-TIP in a 2D temporal-spatial coordinate system:\n%% EQK-TIP in a 2D temporal-spatial coordinate system\n\ndir_png = fullfile(dir_jointstation,'png', 'EQKTIP3'); mkdir(dir_png);\n\n% Find the data of ID 'AMn6ei' and filter tag 'ULF_A'\n\njid = 'AMn6ei';\nfilter_tag = 'ULF_A';\n\njpathlist = datalist(sprintf('[JointStation]ID[%s]prp[%s]*.mat', jid, filter_tag), dir_jointstation).fullpath;\n\n% Retrieve essential data from '[JointStation]' files in the jpathlist:\n\n[AlarmedRate, MissingRate,xlabels, EQKs, TIP3s, TIPv3s, TIPTimes, LatLons] = ...\n    calcFittingDegree(jpathlist);\n\n% Plot EQK-TIP on a 2D temporal-spatial coordinates\n\ntitletag = sprintf('EQK-TIP (trial ID: %s; filter: %s)', jid, filter_tag)\nplotEQKTIP3(dir_png, titletag, xlabels, EQKs, TIP3s, TIPv3s,TIPTimes, LatLons);\n\n\n\nEQK-TIP plot in temporal-spatial coordinates explained.\n\n\n\n\nPlot fitting degree\n%% Plot fitting degree\n\ndir_png = fullfile(dir_jointstation,'fitting_degree'); mkdir(dir_png);\n\nplotFittingDegree(dir_jointstation,dir_catalog,dir_png,...\n    'ConfidenceLevel',0.95);\n\n\n\n\n\nAn example of fitting degree plot.\n\n\n\n\nPlot probability map\n%% Plot probability map\n\n% the output directory for the images\ndir_prob = fullfile(dir_jointstation,'png','prob'); \n\n% specific datetime to be plotted\ndates2plot = [datetime(2020,12,1):caldays(30):datetime(2021,2,11)]';\n\n% plot GEMS-MagTIP probability map \n% (export individual image for each date)\ndir_prob2 = plotProbability(dir_jointstation,dir_catalog,dir_prob, ...\n            'TimeRange',dates2plot,...\n            'PlotEpicenter','all'); \n);\n\n\n\n\n\n\n\nAn example of probability plot. In this figure, the triangle denotes the location of station; circle(s) around each station denote the maximum and minimum range of detection (\\(R_C\\)) of the models that are responsible for calculating the TIPs; the filled color of the triangle denotes the ratio of valid models of the day; and hollow triangle denotes the station that cannot provide TIP for the day."
  }
]