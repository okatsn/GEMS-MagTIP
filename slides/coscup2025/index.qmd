---
title: "GEMS-MagTIP: Scientific Data Processing with Julia"
subtitle: "Leveraging Julia's Type System for Geophysical Data Analysis"
author: "CGRG Lab"
format:
  revealjs:
    theme: [default, custom.css]
    slide-number: true
    code-fold: false
    highlight-style: github
    transition: slide
    background-transition: fade
    footer: "GEMS-MagTIP Package | github.com/okatsn/GEMSMagTIP.jl"
---

# About me 

I'm Tsung-Hsi, Wu (吳宗羲)

- **Affiliation**: National Central University, Dept. of Earth Sciences (postdoc research fellow).
- **Expertise**: geophysics; earthquake dynamics; stochastic process
- **Hobby**: programming with julia, rock climbing
- **Contact me**: [okatsn@gmail.com](); [https://github.com/okatsn](https://github.com/okatsn)

![](https://raw.githubusercontent.com/okatsn/COSCUP_2023_Slides/master/about_twaiswcf/AboutMe_causual.jpg){.absolute bottom=360 right=0 width=300}

<!-- TODO: Import images and use local images instead. -->


## Main Research Topics {.scrollable .unlisted}

My research in Earth Sciences focuses on innovative methodologies and analytical techniques to enhance the understanding of <span class="fragment highlight-forestgreen" fragment-index=1>stochastic earthquake dynamics</span>, <span class="fragment highlight-indianred" fragment-index=2>earthquake precursor detection</span>, and <span class="fragment highlight-steelblue" fragment-index=3>soil water content estimation</span>. 
Below are the main areas of my research:

::: {.image-container}
![](Fig_research_roadmap.png){width="1920px" fig-align="center"}
:::

<!-- TODO: import images -->


# TODO: <Section name>

## What is GEMS-MagTIP?

- Julia package for **G**eophysical **E**lectromagnetic **M**agnetic **S**ignal analysis
- Focuses on Magnetic Thermal Ionization Precursors (MagTIP)
- Provides data deserialization from GEMS-MagTIP-insider MATLAB outputs
- Built with core Julia principles: multiple dispatch, type stability, composability

## Design Philosophy

- Leverages Serde.jl for serialization/deserialization
- Extensible design for handling diverse geophysical data formats
- Comprehensive test coverage ensuring reliability

## Key Data Structures

:::: {.columns}
::: {.column width="50%"}
- **Phase**: Time period representation
- **FittingDegree**: Model fitting statistics 
- **BestModels**: Optimized parameter sets
:::
::: {.column width="50%"}
- **StatInd**: Statistical indicators
- **Info**: Metadata and configuration
:::
::::

## Why Julia for GEMS-MagTIP?

- **Multiple Dispatch for Flexibility**  
  Incorporates Julia’s multiple dispatch system to seamlessly handle different data types and structures without extra boilerplate. This leads to code that is more expressive and adaptable.

- **Type Stability & High Performance**  
  Julia’s type system ensures predictable performance that often rivals or surpasses traditional languages like C or Fortran, making it well-suited for intensive tasks in geophysical analytics.

- **Compared to Python**  
  While Python is popular and has an extensive ecosystem, Julia’s just-in-time (JIT) compilation can yield significant performance benefits. The GEMSMagTIP package leverages this advantage for faster data processing and near-C speeds.

- **Developer Productivity**  
  Julia’s concise syntax, built-in package manager, and powerful metaprogramming features reduce overhead when developing large-scale scientific applications. GEMSMagTIP uses these features to produce modular, maintainable code.

- **Future-Proof & Community-Driven**  
  Julia is quickly evolving with a dynamic open-source community. Its growing ecosystem ensures that packages like GEMSMagTIP keep pace with modern scientific computing trends.

## Design Pattern Highlights

- **Composable Modules**  
  The codebase is structured into modules (`Phase`, `FittingDegree`, `BestModels`, `StatInd`, `Info`) that communicate coherently while preserving independence. This design supports easier testing and upgrades.

- **Serde.jl Integration**  
  GEMSMagTIP heavily relies on Serde.jl for serialization and deserialization, ensuring consistent data interchanges across various formats.

- **Test-Driven Confidence**  
  A robust suite of tests ensures that changes to any single component do not break other parts, simplifying maintenance and allowing incremental feature additions.

# Conceptual flow

Julia Object ⟷ External Format (JSON, CSV)


## Introducing [Serde](https://gemini.google.com/app/dec6da4247bff4a4): A format-agnostic (de)serialization framework



## Serde.jl

<iframe src="https://bhftbootcamp.github.io/Serde.jl/stable/" width="100%" height="500px"></iframe>

- Provides serialization/deserialization between Julia objects and external formats
- Clean, consistent API for converting to/from JSON, CSV, and other formats
- Type-driven architecture fits perfectly with Julia's design philosophy
- Enables seamless data exchange with minimal boilerplate


## Serde.jl Integration in GEMSMagTIP

```julia
# Core design principle
using Serde  # Provides generic ser/deser interfaces

# Type definition with serialization support
struct BestModels
    Mc::Float64
    Rc::Float64
    # ... other fields
    frc::Phase  # Nested structured type
end

# FIXME: where?
# Registering for (de)serialization
Serde.SerCsv.register(BestModels)
```

## JSON Deserialization Example

```julia
# Deserializing a JSON object into strongly-typed Julia struct
json_data = """
{
    "Identifier": "JF5lTN",
    "FunctionNames": ["S", "K"],
    "FunctionHandles": ["skewness", "kurtosis"],
    "TrainingPhase": [["01-Apr-2014", "01-Apr-2017"], 
                      ["01-Oct-2014", "01-Oct-2017"]]
}
"""

# One-line deserialization into Info struct
info = deser_json(GEMSMagTIP.Info, json_data)

# Access strongly-typed data
println("ID: $(info.Identifier)")
```

## CSV Deserialization Example

```julia
# Reading CSV data into strongly-typed objects
csv_data = """
Mc,Rc,NthrRatio,Tobs,prp,frc,stn,FittingDegree
5,50,0.001,5,BP_35,20170402-20170928,CHCH,0.782
5,60,0.001,5,BP_35,20170402-20170928,CHCH,0.782
"""

# Convert to Vector of BestModels objects
models = Serde.deser_csv(GEMSMagTIP.BestModels, csv_data)

# Access first model with full type information
println("Station: $(models[1].stn), Score: $(models[1].FittingDegree)")
println("Date range: $(models[1].frc.t0) to $(models[1].frc.t1)")
```

## The Julia Advantage: Type-Driven Approach and The Power of Multiple Dispatch

```julia
# Type-driven parsing (from core_read.jl)
function core_read(::Val{file_bestmodels}, path)
    data = read_data(path, DataFrame) # Generic read
    # Automatic type conversion based on BestModels definition
    return read_data(path, Vector{BestModels})
end

# Multiple dispatch selects appropriate method
function deser(::Type{Phase}, s::AbstractString)
    # Parse dates from string like "20170402-20170928"
    t0 = Date(s[1:8], dateformat"yyyymmdd")
    t1 = Date(s[10:end], dateformat"yyyymmdd")
    return Phase(t0, t1)
end

# Multiple ways to construct dates by dispatch

# From string with format "20170402-20170928"
function deser(::Type{Phase}, s::AbstractString)
    t0 = Date(s[1:8], dateformat"yyyymmdd")
    t1 = Date(s[10:end], dateformat"yyyymmdd")
    return Phase(t0, t1)
end

# From array of string dates ["01-Apr-2017", "28-Sep-2017"]
function deser(::Type{Phase}, v::AbstractVector)
    t0 = Date(v[1], info_date_format)
    t1 = Date(v[2], info_date_format)
    return Phase(t0, t1)
end

# The client code is the same regardless of format:
phase = deser(Phase, date_string)  # Works with any format
```

## Type Conversion: One Method, Many Uses

```julia
# Define a single conversion method for Phase type
function Serde.deser(::Type{GEMSMagTIP.Phase}, data::AbstractString)
    # Works for any field of type Phase across different structs
    return GEMSMagTIP.Phase(data)
end

# The actual Phase constructor handles the parsing
function Phase(data::AbstractString)
    v = split(data, "-")
    return Phase(Dates.Date.(v, frc_date_format))
end

# Usage remains simple regardless of complexity
models = read_data("bestModels.csv", Vector{BestModels})
stats = read_data("StatInd.csv", Vector{StatInd})
```

## Complex Data Transformation: StatInd Example

```julia
# Transforming complex CSV with many columns into structured data

# Original CSV has many var_* columns
csv_row = "01-Jan-2014,CHCH,AMn6ei,BP_35,-0.092,-1.318,4.379,..."

# After deserialization, we get a structured object:
stat = first(read_data("StatInd.csv", Vector{StatInd}))

# All related variables are grouped in a NamedTuple
println(stat.DateTime)  # Date(2014, 1, 1)
println(stat.var.var_S_NS)  # -0.092
println(stat.var.var_K_EW)  # 13.064
```

## File-based Dispatch Pattern

```julia
# File-based dispatch pattern (core_read.jl)
function core_read(path)
    fname = basename(path)
    core_read(Val(Symbol(fname)), path) # Dispatch by filename
end

# Dispatch to specific file types (const_filename.jl)
const file_bestmodels = Symbol("bestModels.csv")
const file_statind = Symbol("StatInd.csv")

# Type-specific handlers
core_read(::Val{file_bestmodels}, path) = _vec_deser(BestModels, path)
core_read(::Val{file_statind}, path) = _statind_deser(StatInd, path)

# General deserialization path - handles most cases
function _vec_deser(T, path)
    rows = CSV.File(path) |> CSV.rowtable
    return Serde.to_deser(Vector{T}, rows) # Convert to typed objects
end

# Special case deserialization for complex transformations
function _statind_deser(T, path)
    stat = CSV.read(path, DataFrame)
    # Group all var_* columns into a single NamedTuple field
    stat1 = @chain stat begin
        transform(AsTable(r"\Avar\_") => ByRow(identity) => :var)
        select(Not(r"\Avar\_"))
    end
    rows = stat1 |> CSV.rowtable
    return Serde.to_deser(Vector{T}, rows)
end
```

## Summary

- **Filename-Driven Logic**: Users don't need to specify data types - the system infers them from filenames
- **Extensibility**: Add support for new file formats by simply defining new dispatch methods
- **Clean Interfaces**: Client code remains simple while complexity is handled behind the scenes
- **Composability**: Each component handles one responsibility:
- **core_read**: Routes by filename
- **Type-specific methods**: Handle special cases
- `Serde.deser`: Handles field-level conversions
- **Real-world** Example: Converting dozens of specialized geophysical data formats without code duplication