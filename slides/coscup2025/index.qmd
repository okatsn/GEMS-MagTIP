---
title: "GEMS-MagTIP: Scientific Data Processing with Julia"
subtitle: "Leveraging Julia's Type System for Geophysical Data Analysis"
author: "CGRG Lab"
format:
  revealjs:
    theme: [default, custom.css]
    slide-number: true
    code-fold: false
    highlight-style: github
    transition: slide
    background-transition: fade
    footer: "GEMS-MagTIP Package | github.com/okatsn/GEMSMagTIP.jl"
---

## What is GEMS-MagTIP?

- Julia package for **G**eophysical **E**lectromagnetic **M**agnetic **S**ignal analysis
- Focuses on Magnetic Thermal Ionization Precursors (MagTIP)
- Provides data deserialization from GEMS-MagTIP-insider MATLAB outputs
- Built with core Julia principles: multiple dispatch, type stability, composability

## Design Philosophy

- Leverages Serde.jl for serialization/deserialization
- Extensible design for handling diverse geophysical data formats
- Comprehensive test coverage ensuring reliability

## Key Data Structures

:::: {.columns}
::: {.column width="50%"}
- **Phase**: Time period representation
- **FittingDegree**: Model fitting statistics 
- **BestModels**: Optimized parameter sets
:::
::: {.column width="50%"}
- **StatInd**: Statistical indicators
- **Info**: Metadata and configuration
:::
::::

## Why Julia for GEMS-MagTIP?

- **Multiple Dispatch for Flexibility**  
  Incorporates Julia’s multiple dispatch system to seamlessly handle different data types and structures without extra boilerplate. This leads to code that is more expressive and adaptable.

- **Type Stability & High Performance**  
  Julia’s type system ensures predictable performance that often rivals or surpasses traditional languages like C or Fortran, making it well-suited for intensive tasks in geophysical analytics.

- **Compared to Python**  
  While Python is popular and has an extensive ecosystem, Julia’s just-in-time (JIT) compilation can yield significant performance benefits. The GEMSMagTIP package leverages this advantage for faster data processing and near-C speeds.

- **Developer Productivity**  
  Julia’s concise syntax, built-in package manager, and powerful metaprogramming features reduce overhead when developing large-scale scientific applications. GEMSMagTIP uses these features to produce modular, maintainable code.

- **Future-Proof & Community-Driven**  
  Julia is quickly evolving with a dynamic open-source community. Its growing ecosystem ensures that packages like GEMSMagTIP keep pace with modern scientific computing trends.

## Design Pattern Highlights

- **Composable Modules**  
  The codebase is structured into modules (`Phase`, `FittingDegree`, `BestModels`, `StatInd`, `Info`) that communicate coherently while preserving independence. This design supports easier testing and upgrades.

- **Serde.jl Integration**  
  GEMSMagTIP heavily relies on Serde.jl for serialization and deserialization, ensuring consistent data interchanges across various formats.

- **Test-Driven Confidence**  
  A robust suite of tests ensures that changes to any single component do not break other parts, simplifying maintenance and allowing incremental feature additions.

# Conceptual flow

Julia Object ⟷ External Format (JSON, CSV)


## Introducing Serde.jl

<iframe src="https://bhftbootcamp.github.io/Serde.jl/stable/" width="100%" height="500px"></iframe>

- Provides serialization/deserialization between Julia objects and external formats
- Clean, consistent API for converting to/from JSON, CSV, and other formats
- Type-driven architecture fits perfectly with Julia's design philosophy
- Enables seamless data exchange with minimal boilerplate


## Serde.jl Integration in GEMSMagTIP

```julia
# Core design principle
using Serde  # Provides generic ser/deser interfaces

# Type definition with serialization support
struct BestModels
    Mc::Float64
    Rc::Float64
    # ... other fields
    frc::Phase  # Nested structured type
end

# FIXME: where?
# Registering for (de)serialization
Serde.SerCsv.register(BestModels)
```

## JSON Deserialization Example

```julia
# Deserializing a JSON object into strongly-typed Julia struct
json_data = """
{
    "Identifier": "JF5lTN",
    "FunctionNames": ["S", "K"],
    "FunctionHandles": ["skewness", "kurtosis"],
    "TrainingPhase": [["01-Apr-2014", "01-Apr-2017"], 
                      ["01-Oct-2014", "01-Oct-2017"]]
}
"""

# One-line deserialization into Info struct
info = deser_json(GEMSMagTIP.Info, json_data)

# Access strongly-typed data
println("ID: $(info.Identifier)")
```

## CSV Deserialization Example

```julia
# Reading CSV data into strongly-typed objects
csv_data = """
Mc,Rc,NthrRatio,Tobs,prp,frc,stn,FittingDegree
5,50,0.001,5,BP_35,20170402-20170928,CHCH,0.782
5,60,0.001,5,BP_35,20170402-20170928,CHCH,0.782
"""

# Convert to Vector of BestModels objects
models = Serde.deser_csv(GEMSMagTIP.BestModels, csv_data)

# Access first model with full type information
println("Station: $(models[1].stn), Score: $(models[1].FittingDegree)")
println("Date range: $(models[1].frc.t0) to $(models[1].frc.t1)")
```

## The Julia Advantage: Type-Driven Approach and The Power of Multiple Dispatch

```julia
# Type-driven parsing (from core_read.jl)
function core_read(::Val{file_bestmodels}, path)
    data = read_data(path, DataFrame) # Generic read
    # Automatic type conversion based on BestModels definition
    return read_data(path, Vector{BestModels})
end

# Multiple dispatch selects appropriate method
function deser(::Type{Phase}, s::AbstractString)
    # Parse dates from string like "20170402-20170928"
    t0 = Date(s[1:8], dateformat"yyyymmdd")
    t1 = Date(s[10:end], dateformat"yyyymmdd")
    return Phase(t0, t1)
end

# Multiple ways to construct dates by dispatch

# From string with format "20170402-20170928"
function deser(::Type{Phase}, s::AbstractString)
    t0 = Date(s[1:8], dateformat"yyyymmdd")
    t1 = Date(s[10:end], dateformat"yyyymmdd")
    return Phase(t0, t1)
end

# From array of string dates ["01-Apr-2017", "28-Sep-2017"]
function deser(::Type{Phase}, v::AbstractVector)
    t0 = Date(v[1], info_date_format)
    t1 = Date(v[2], info_date_format)
    return Phase(t0, t1)
end

# The client code is the same regardless of format:
phase = deser(Phase, date_string)  # Works with any format
```

## Complex Data Transformation: StatInd Example

```julia
# Transforming complex CSV with many columns into structured data

# Original CSV has many var_* columns
csv_row = "01-Jan-2014,CHCH,AMn6ei,BP_35,-0.092,-1.318,4.379,..."

# After deserialization, we get a structured object:
stat = first(read_data("StatInd.csv", Vector{StatInd}))

# All related variables are grouped in a NamedTuple
println(stat.DateTime)  # Date(2014, 1, 1)
println(stat.var.var_S_NS)  # -0.092
println(stat.var.var_K_EW)  # 13.064
```